\newchapter{Cryptography}
\index{Cryptography}
\index{Cryptanalysis}
Cryptography is the practice and study of techniques for~secure communication.
It~focuses on~constructing and~analyzing protocols that prevent third parties or~the~public from reading private messages between a~sender and a~receiver, i.e., on~encrypting and~decrypting of~messages.
The~study of~breaking cryptographic techniques and~reading encrypted messages by~third parties (i.e., what bad~guys are~doing) is called \textit{cryptanalysis}.

In~computer cryptography the~encrypted message can~be any~data, i.e., any~set of~bits, most techniques operate with bytes.
No~matter what is~encrypted (string, file,~\dots), it's~transferred to~bits and~these are~then given~to an~encryption algorithm, which produces another set of~bits (encrypted data).
You~can often encounter a~situation when the~result of an~encryption algorithm is shown as an~ASCII string\,--\,although just a~mess of~characters, there~is no issue with displaying any character (this is not normal for an~arbitrary set of bits/bytes).
That's because the~result was in~some (sometimes maliciously hidden) step transferred to~string by~some binary--to--text encoding, most usually \hyperref[base64]{Base64}.

\newsection{Key}
A~key is an~information (a~parameter) given to a~cryptographic function when encrypting and decrypting messages.
Either the~same key is used for both encryption and~decryption (\hyperref[symmetriccryptography]{symmetric cryptography}) or~there is a~pair of~keys, one for~encryption and~one for~decryption (\hyperref[asymmetriccryptography]{asymmetric cryptography}).

In~computer cryptography the~key is a~set of~bits, usually bytes, similarly to~data itself.
And~similarly to~encrypted data it's often shown as a~printable string.
Even in~this case the~binary--to--text encoding is in~action, keys are~not fully printable by~default.
Typically the~longer your message is, the~longer key you need.

\newsection{Symmetric Cryptography}
\index{Symmetric cryptography}
\label{symmetriccryptography}
In~this type of~cryptography there is~one common key used for~both encryption and~decryption.
The~message processing flow~is:
\begin{itemize}
    \item A~sender owns the key.
          He encrypts the~message with the~key and~sends it to a~receiver.
    \item The~receiver has the~same key, which he uses to decrypt the message.
\end{itemize}

\newsubsection{AES}
\index{AES}
\index{Initial vector}
A~typical example of a~symmetric cryptography algorithm is \textit{AES} (\textit{Advanced Encryption Standard}).
It~requires the~key to~be 128, 192 or~256 bits (16, 24 or~32 bytes) long, that's why some implementations require the~key to be specified as a~string of~16, 24 or~32 ASCII characters (one~character\,--\,one~byte).
The~encryption can~be extended with so~called \textit{initial vector}.
It's another set of~bits given to the~algorithm together with the~key when encrypting, but opposite to the~key the~initial vector is usually always different.
It must~be then sent to~the receiver together with the~message, because it's needed also for the~message decryption.
However, it~can~be sent through a~different secure canal, and as it's quite short, it~can~be encrypted by an~\hyperref[asymmetriccryptography]{asymmetric encryption}.
The~length of an~initial vector must be always 128 bits (16 bytes).

The~big disadvantage of~this approach is that the~key needs to be shared, i.e., two copies of~it must~be distributed to both sender and~receiver.
And~during this distribution (e.g., sending it over a~network) it can~be caught by a~bad guy.
Reasons why the~symmetric cryptography still survives is its high speed and~practically unlimited size of~processed data (opposite to the~\hyperref[asymmetriccryptography]{asymmetric cryptography}), the~limit is in millions of~\mbox{terabytes}.

\newsection{Asymmetric Cryptography}
\index{Asymmetric cryptography}
\index{Public key cryptography}
\label{asymmetriccryptography}
In~this type of~encryption there are two keys matching to~each other - public and~private.
Messages encrypted by a~public key can~be decrypted only~by a~matching private key.
That's why it's sometimes also called \textit{public key cryptography}.
It can work also in the~reversed way (encrypted by private key, decrypted by public key), which is used in \hyperref[electronicsignature]{electronic signatures}.
The~message processing flow~is:
\begin{itemize}
    \item A~sender owns the~public key.
          He~encrypts the~message with the~public key and~sends it to a~receiver.
    \item The~receiver has the~matching private key, which he~uses to~decrypt the~message.
\end{itemize}

\noindent The~main security benefit in this approach is that the~private key used for~discovering messages contents is never shared, only the receiver owns~it.
Nobody else can read those messages.
Typically the receiver generates a~pair of~keys and sends the~public key to~whoever he~wants to~receive messages from.
If someone else gets the~public key, there is no problem, he won't be able to~decrypt messages sent to~the~receiver.
\newpage

\newsubsection{RSA}
\index{RSA}
\label{rsa}
\textit{RSA} is the~most well--known asymmetric encryption algorithm.
It's used for~both encrypting sent data and~\hyperref[electronicsignature]{electronic signatures}.
The abbreviation is nothing technical, it~consists of initial letters of~names of~authors of~the algorithm\,--\,\textit{Rivest}, \textit{Shamir}, \textit{Adleman}.

Disadvantages of~this approach are message length limits and~performance demands.
In~RSA with a~2048 bits (256~bytes) key the~maximum message length is 245 bytes.
And~with too big keys the~computational time grows, the~maximum reasonable key length today is 4096 bits (512~bytes).
On~the~other hand with too short key the~security drops, so~the~minimum secure key length today is 2048 bits (256~bytes).

\newsubsection{RSA Key Length}
\index{Modulus}
The~length of a~key is in~fact only the~length of~so called \textit{modulus}, which is some hidden number that both public and~matching private key have in common.
There is also additional info encoded in keys, this info is needed for~the~RSA algorithm.
That's why both keys in the~pair contain more bits than the number specified during their generation.
There is more such info in private keys, that's why private keys are significantly longer than matching public keys.

\warning Although only some fixed lengths of the~key are~mentioned almost everywhere (512, 1024, 2048, 4096), there is no restriction, the~length can~be any number.
However, the~\textit{ssh-keygen} program provided with Git installation, which is usually used for~key generation, doesn't allow number lower than 1024.

\newsubsection{RSA Key Formats}
\newline\todo OpenSSH, PKCS1, PKCS8\dots

\newsection{Electronic Signature}
\index{Electronic signature}
\label{electronicsignature}
Electronic signature uses the~\hyperref[asymmetriccryptography]{asymmetric cryptography principle} to~verify the~identity of~a~data sender.
The~application of~keys is reversed than in~the~asymmetric encryption.
A~sender uses the~private key to~sign sent data and~a~receiver uses the~public key to~verify the~signature.

A~hash is generated from the~sent message.
The~hashing function must work so that even a~slight change of~the~message causes a~significant change of~the~hash.
The~hash is then encrypted with th~sender's private key.
This encrypted hash is the~electronic signature of~the~message and~it's sent together with the~original message to~the~receiver.
The receiver creates the~hash from the~original message and~decrypts the~signature, which gives him another hash.
He~compares the~hash of~the~message and~the~hash of~the~signature.
If~they match, the~signature is verified.

\newsection{Certification Authority}
\index{Certification authority}
\label{certificationauthority}
It's~something (typically some trusted and~state certified company) which can~verify that public keys used for~\hyperref[asymmetriccryptography]{asymmetric cryptography} and~\hyperref[electronicsignature]{electronic signatures} really belong to~users they claim (a~public key identifies a~user).
In~standard asymmetric encryption it~serves for~senders to~verify that they really encrypt messages with public keys they got from receivers.
In~electronic signature it~serves for~receivers to~verify that public keys they use for~the~signature verification really belong to~senders they get messages from.

Certification authorities are usually paid, that sucks.
An alternative can~be key sharing servers used~by some dedicated software like \hyperref[pgpgpg]{PGP} (this is commercial software though) or~\hyperref[pgpgpg]{GPG} (that's true free).

\newsubsection{PGP and GPG}
\index{PGP}
\index{GPG}
\index{Pretty Good Privacy}
\index{GNU Privacy Guard}
\label{pgpgpg}
These are computer programs for~handling \hyperref[asymmetriccryptography]{asymmetric cryptography} and~\hyperref[electronicsignature]{electronic signatures}.
Users either send their public keys directly to~each other or~they can~upload them to~dedicated servers, from where other users can~download them.
These servers can~serve as~alternatives to~\hyperref[certificationauthority]{certification authorities}.

User's keys are~stored in~the~local program installation and~accessed by~passwords.
When using private keys (decrypting a message, signing), the~user doesn't have to~copy the~whole long key anywhere, he~only provides the~password.

PGP~stands for~\itq{Pretty Good Privacy}.
It's~a~commercial software,~i.e.,~users need to~pay for~it.
GPG,~standing for~\itq{\hyperref[gnu]{GNU} Privacy Guard}, is~a~free alternative.

\newsection{Why to use GPG signature in Git}
\label{gitgpg}
SSH~keys only serve for~access right to a~\hyperref[git]{Git} repository.
They can't~be used for~user identity verification.
Anyone who has access to a~GitHub can pretend to be someone else.
User names and~emails depend only on the~local Git configuration.
For~example, consider that you have an~access to a~GitHub.
You~generate an~SSH key on~your computer and~upload it to the~GitHub.
And~next you configure your local Git like this:
\begin{lstlisting}[frame=no]
    git config --global user.name "Homer Simpson"
    git config --global user.email homersimpson@burnspowerplant.com
\end{lstlisting}
\noindent Whoever you are, your commits will look like Homer made them.
But~GPG keys are~connected with user names and~addresses, furthermore they're protected by a~password.
With a~Git hub requiring GPG signing of~commits you~can't push unsigned commits and~you~can't sign without knowing the~password.
When you configure your Git to~sign commits you~can't even commit without signing.

If~you could generate and~add keys yourself, it~would lack any~sense.
But~when there is an~authority that distributes keys (which is usually the~case), your Homer identity is~screwed.
The~authority will give you only the~private key that matches your real name and~email and~it will upload matching public key to~the~GitHub itself.
The~authority in~this case is an~application with a~database of~allowed user names and~emails.

\newsection{Certificate}
\index{Certificate}
\index{CSR}
\label{certificate}
A~certificate is simply a~public key with additional metadata.
Sometimes it can~contain even the~private key.
Metadata in~certificates serve for~identifying owners of~keys.

When someone provides a~public key to~verify signatures coming from~him, it~isn't possible to~verify that the~key really belongs to~that someone.
Identity information isn't included in~the~key.
But~when he provides a~certificate, a~receiver can~verify the~identity based on metadata in~the~certificate.

Obtaining a~certificate that is trusted by~others isn't just like that.
The~sender must request it from~a~\hyperref[certificationauthority]{certification authority}\,--\,he~must send so~called \textit{certificate signing request}~(CSR) to~the~authority (and~of~course he~must~pay).
The~request is just a~file, typically with the~\itq{.csr} extension, which contains sender's public key and~some information about~him.
When the~authority verifies all the~information from~the~request (and~gets the~money), it~creates the~certificate, signs it with its private key (standard electronic signature described \hyperref[electronicsignature]{earlier}), appends the~signature to~the~certificate and~returns it to~the~sender.
Now~the~sender has a~valid certificate and~he~can~provide it to~receivers.
Receivers can~extract the~public key from the~certificate and~verify sender's signatures with~it.
If~they want to~verify the~sender's identity, they verify the~signature in~the~certificate using a~public key of~the~certification authority (the~authority signed the~certificate with its private key before).

\newsection{SSL/TLS}
\index{SSL}
\index{TLS}

\newsection{PKCS}
The~abbreviation stands for~\itq{Public Key Cryptography Standards}.
It's~a~set of~standards for~various scenarios in~\hyperref[asymmetriccryptography]{asymmetric cryptography} created by \href{https://en.wikipedia.org/wiki/RSA_Security}{RSA~Security}.
You~will often encounter the~abbreviation with a~number, sometimes with hash tag.
This denotes one concrete standard from~the~set.
Most important PKCS standards~are:
\begin{itemize}
    \itembfd{PKCS~\#1} first standard of~the~PKCS family, provides basic definitions~of and~recommendations for~implementing the~\hyperref[rsa]{RSA~algorithm}.
             Defines mathematical properties of~public and~private keys, primitive operations for~encryption and~signatures, secure cryptographic schemes and~related syntax representations.
    \itembfd{PKCS~\#8} defines handling of~private keys in~any~asymmetric \hyperref[asymmetriccryptography]{asymmetric cryptography} algorithm.
             It~isn't fixed only to~the~\hyperref[rsa]{RSA~algorithm} (opposite to~PKCS~\#1).
    \itembfd{PKCS~\#12} defines an~archive file format for~storing many cryptography objects into a~single file, for~example, a~private key and~a~corresponding \hyperref[certificate]{certificate}.
             Files created according to~this standard have extensions \itq{.pfx} or~\itq{.p12}.
\end{itemize}
