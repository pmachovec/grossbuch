\newchapter{Cryptography}
\index{Cryptography}
\index{Cryptanalysis}
\label{cryptography}
Cryptography is the practice and study of techniques for~secure communication.
It~focuses on~constructing and~analyzing \hyperref[protocolstandard]{protocols} that prevent third parties or~the~public from reading private messages between a~sender and a~receiver, i.e., on~encrypting and~decrypting of~messages.
The~study of~breaking cryptographic techniques and~reading encrypted messages by~third parties (i.e., what bad~guys are~doing) is called \textit{cryptanalysis}.

In~computer cryptography the~encrypted message can~be any~data, i.e., any~set of~bits, most techniques operate with bytes.
No~matter what is~encrypted (string, file,~\dots), it's~transferred to~bits and~these are~then given~to an~encryption algorithm, which produces another set of~bits (encrypted data).
You~can often encounter a~situation when the~result of an~encryption algorithm is shown as an~ASCII string\,--\,although just a~mess of~characters, there~is no issue with displaying any character (this is not normal for an~arbitrary set of bits/bytes).
That's because the~result was in~some (sometimes maliciously hidden) step transferred to~string by~some binary--to--text encoding, most usually \hyperref[base64]{Base64}.

\newsection{Key}
A~key is an~information (a~\hyperref[parameterargument]{parameter}) given to a~cryptographic function when encrypting and decrypting messages.
Either the~same key is used for both encryption and~decryption (\hyperref[symmetriccryptography]{symmetric cryptography}) or~there is a~pair of~keys, one for~encryption and~one for~decryption (\hyperref[asymmetriccryptography]{asymmetric cryptography}).

In~computer cryptography the~key is a~set of~bits, usually bytes, similarly to~data itself.
And~similarly to~encrypted data it's often shown as a~printable string.
Even in~this case the~binary--to--text encoding is in~action, keys are~not fully printable by~default.
Typically the~longer your message is, the~longer key you need.
\newpage

\newsection{Symmetric Cryptography}
\label{symmetriccryptography}
In~this type of~cryptography there is~one common key used for~both encryption and~decryption.
This key should be always kept secret and~shared with caution, that's why also the~term \itq{private key cryptography} is~used.
The~message processing flow~is:
\begin{itemize}
    \item A~sender owns the key.
          He encrypts the~message with the~key and~sends it to a~receiver.
    \item The~receiver has the~same key, which he uses to decrypt the message.
\end{itemize}

\newsubsection{AES}
\index{AES}
\index{Initial vector}
A~typical example of a~symmetric cryptography algorithm is \textit{AES} (\textit{Advanced Encryption Standard}).
It~requires the~key to~be 128, 192 or~256 bits (16, 24 or~32 bytes) long, that's why some implementations require the~key to be specified as a~string of~16, 24 or~32 ASCII characters (one~character\,--\,one~byte).
The~encryption can~be extended with so~called \textit{initial vector}.
It's another set of~bits given to the~algorithm together with the~key when encrypting, but opposite to the~key the~initial vector is usually always different.
It must~be then sent to~the receiver together with the~message, because it's needed also for the~message decryption.
However, it~can~be sent through a~different secure canal, and as it's quite short, it~can~be encrypted by an~\hyperref[asymmetriccryptography]{asymmetric encryption}.
The~length of an~initial vector must be always 128 bits (16 bytes).

The~big disadvantage of~this approach is that the~key needs to be shared, i.e., two copies of~it must~be distributed to both sender and~receiver.
And~during this distribution (e.g., sending it over a~network) it can~be caught by a~bad guy.
Reasons why the~symmetric cryptography still survives is its high speed and~practically unlimited size of~processed data (opposite to the~\hyperref[asymmetriccryptography]{asymmetric cryptography}), the~limit is in millions of~\mbox{terabytes}.

\newsubsection{AES Key Formats}
AES~keys are~just byte sequences, usually random, carrying no further information.
They're usually represented as~hexadecimal strings (one~byte\,=\,two~characters), sometimes with spaces between character couples.
They can~be also written in~the~\hyperref[base64]{\mbox{Base64}} encoding.
Storing key bytes to~a~file of~a~desired size is~also possible, in~that case it~creates an~unreadable mess.
\newpage

\newsection{Asymmetric Cryptography}
\label{asymmetriccryptography}
In~this type of~encryption there are two keys matching to~each other - public and~private.
Messages encrypted by a~public key can~be decrypted only~by a~matching private key.
That's why it's sometimes also called \itq{public key cryptography}.
It can work also in the~reversed way (encrypted by private key, decrypted by public key), which is used in \hyperref[electronicsignature]{electronic signatures}.
The~message processing flow~is:
\begin{itemize}
    \item A~sender owns the~public key.
          He~encrypts the~message with the~public key and~sends it to a~receiver.
    \item The~receiver has the~matching private key, which he~uses to~decrypt the~message.
\end{itemize}

\noindent The~main security benefit in this approach is that the~private key used for~discovering messages contents is never shared, only the receiver owns~it.
Nobody else can read those messages.
Typically the receiver generates a~pair of~keys and sends the~public key to~whoever he~wants to~receive messages from.
If someone else gets the~public key, there is no problem, he won't be able to~decrypt messages sent to~the~receiver.

\newsubsection{RSA}
\index{RSA}
\label{rsa}
\textit{RSA} is the~most well--known asymmetric encryption algorithm.
It's used for~both encrypting sent data and~\hyperref[electronicsignature]{electronic signatures}.
The abbreviation is nothing technical, it~consists of initial letters of~names of~authors of~the algorithm\,--\,\textit{Rivest}, \textit{Shamir}, \textit{Adleman}.

Disadvantages of~this approach are message length limits and~performance demands.
In~RSA with a~2048 bits (256~bytes) key the~maximum message length is 245 bytes.
And~with too big keys the~computational time grows, the~maximum reasonable key length today is 4096 bits (512~bytes).
On~the~other hand with too short key the~security drops, so~the~minimum secure key length today is 2048 bits (256~bytes).

\newsubsection{RSA Key Length}
\index{Modulus}
The~length of a~key is in~fact only the~length of~so called \textit{modulus}, which is some hidden number that both public and~matching private key have in common.
There is also additional info encoded in keys, this info is needed for~the~RSA algorithm.
That's why both keys in the~pair contain more bits than the number specified during their generation.
There is more such info in private keys, that's why private keys are significantly longer than matching public keys.

\warning Although only some fixed lengths of the~key are~mentioned almost everywhere (512, 1024, 2048, 4096), there is no restriction, the~length can~be any number.
However, the~\textit{ssh-keygen} program provided with Git installation, which is usually used for~key generation, doesn't allow number lower than 1024.

\newsubsection{RSA Key Formats}
\index{OpenSSH}
RSA~keys are~most often represented as~\hyperref[base64]{\mbox{Base64}} encoded strings, even when stored in~files.
Files with RSA~keys are usually in~the~\hyperref[pem]{PEM} format.
Keys can~follow either \hyperref[pkcs]{PKCS~\#1} or~\hyperref[pkcs]{PKCS~\#8} standard.
In~the~first case they're usable only in~the~RSA~algorithm, in~the~second case they can~be used even in~different asymmetric cryptography algorithms.

Public keys are sometimes represented also in~the~\mbit{OpenSSH} format.
A~public key in~the~OpenSSH format incorporates also a~user email, which must~be provided during key~generation
This format is~used for~manual public key exchange combined with~\hyperref[authenticationauthorization]{authentication}, for~example on~GitHubs.
Private keys are never represented in~this format.

\example[a~public key in~the~OpenSSH format]
\begin{lstlisting}
    ssh-rsa AAAAB3NzaC1yc2... jbravo@gmail.com
\end{lstlisting}
\newline

\noindent \textbf{The same public key in PEM PKCS~\#1 format}
\begin{lstlisting}
    -----BEGIN RSA PUBLIC KEY-----
    MIIBCgKCAQEAwNUeQzY4mlj1sAH2zLZFUSOf7yMGjpVKp7LgxnKQDUNXbA8WSt/E
    oM/IkHGq35yFOpXevsIF2Xp7oO4md/muTWcecqCG7k1MAJLz9ZUiMikVfEB9DnhH
    ...
    1W/oG/iF1qlnQJq7X/tjKUoX7yUhpZLu9wIDAQAB
    -----END RSA PUBLIC KEY-----
\end{lstlisting}
\newline

\noindent \textbf{The same public key in PEM PKCS~\#8 format}
\begin{lstlisting}
    -----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwNUeQzY4mlj1sAH2zLZF
    USOf7yMGjpVKp7LgxnKQDUNXbA8WSt/EoM/IkHGq35yFOpXevsIF2Xp7oO4md/mu
    ...
    9wIDAQAB
    -----END PUBLIC KEY-----
\end{lstlisting}
\noindent Note there's no \textit{RSA} word the~header and~the~footer.
\newpage

\newsection{Electronic Signature}
\index{Electronic signature}
\label{electronicsignature}
Electronic signature uses the~\hyperref[asymmetriccryptography]{asymmetric cryptography principle} to~verify the~identity of~a~data sender.
The~application of~keys is reversed than in~the~asymmetric encryption.
A~sender uses the~private key to~sign sent data and~a~receiver uses the~public key to~verify the~signature.

A~hash is generated from the~sent message.
The~hashing function must work so that even a~slight change of~the~message causes a~significant change of~the~hash.
The~hash is then encrypted with th~sender's private key.
This encrypted hash is the~electronic signature of~the~message and~it's sent together with the~original message to~the~receiver.
The receiver creates the~hash from the~original message and~decrypts the~signature, which gives him another hash.
He~compares the~hash of~the~message and~the~hash of~the~signature.
If~they match, the~signature is verified.

\newsection{Certification Authority}
\index{Certification authority}
\label{certificationauthority}
It's~something (typically some trusted and~state certified company) which can~verify that public keys used for~\hyperref[asymmetriccryptography]{asymmetric cryptography} and~\hyperref[electronicsignature]{electronic signatures} really belong to~users they claim (a~public key identifies a~user).
In~standard asymmetric encryption it~serves for~senders to~verify that they really encrypt messages with public keys they got from receivers.
In~electronic signature it~serves for~receivers to~verify that public keys they use for~the~signature verification really belong to~senders they get messages from.

Certification authorities are usually paid, that sucks.
An alternative can~be key sharing servers used~by some dedicated software like \hyperref[pgpgpg]{PGP} (this is commercial software though) or~\hyperref[pgpgpg]{GPG} (that's true free).

\newsubsection{PGP and GPG}
\index{PGP}
\index{GPG}
\index{Pretty Good Privacy}
\index{GNU Privacy Guard}
\label{pgpgpg}
These are computer programs for~handling \hyperref[asymmetriccryptography]{asymmetric cryptography} and~\hyperref[electronicsignature]{electronic signatures}.
Users either send their public keys directly to~each other or~they can~upload them to~dedicated servers, from where other users can~download them.
These servers can~serve as~alternatives to~\hyperref[certificationauthority]{certification authorities}.

User's keys are~stored in~the~local program installation and~accessed by~passwords.
When using private keys (decrypting a message, signing), the~user doesn't have to~copy the~whole long key anywhere, he~only provides the~password.

PGP~stands for~\itq{Pretty Good Privacy}.
It's~a~commercial software,~i.e.,~users need to~pay for~it.
GPG,~standing for~\itq{\hyperref[gnu]{GNU} Privacy Guard}, is~a~free alternative.
\newpage

\newsection{Why to use GPG signature in Git}
\label{gitgpg}
SSH~keys only serve for~access right to a~\hyperref[git]{Git} repository.
They can't~be used for~user identity verification.
Anyone who has access to a~GitHub can pretend to be someone else.
User names and~emails depend only on the~local Git configuration.
For~example, consider that you have an~access to a~GitHub.
You~generate an~SSH key on~your computer and~upload it to the~GitHub.
And~next you configure your local Git like this:
\begin{lstlisting}[frame=no]
    git config --global user.name "Homer Simpson"
    git config --global user.email homersimpson@burnspowerplant.com
\end{lstlisting}
\noindent Whoever you are, your commits will look like Homer made them.
But~GPG keys are~connected with user names and~addresses, furthermore they're protected by a~password.
With a~Git hub requiring GPG signing of~commits you~can't push unsigned commits and~you~can't sign without knowing the~password.
When you configure your Git to~sign commits you~can't even commit without signing.

If~you could generate and~add keys yourself, it~would lack any~sense.
But~when there is an~authority that distributes keys (which is usually the~case), your Homer identity is~screwed.
The~authority will give you only the~private key that matches your real name and~email and~it will upload matching public key to~the~GitHub itself.
The~authority in~this case is an~application with a~database of~allowed user names and~emails.

\newsection{Certificate}
\index{Certificate}
\index{Public key certificate}
\index{Digital certificate}
\index{CSR}
\label{certificate}
A~certificate, also public key certificate or~digital certificate, is simply a~public key with additional metadata.
Sometimes it can~contain even the~private key.
Metadata in~certificates serve for~identifying owners of~keys.

When someone provides a~public key to~verify signatures coming from~him, it~isn't possible to~verify that the~key really belongs to~that someone.
Identity information isn't included in~the~key.
But~when he provides a~certificate, a~receiver can~verify the~identity based on metadata in~the~certificate.

\newsubsection{TLS}
\index{TLS}
\index{SSL}
\index{Transport layer security}
\index{Secure sockets layer}
\index{Root certificate}
\index{Root store}
\index{Trusted store}
\index{PKI}
\index{Public Key Infrastructure}
\label{tls}
TLS,~standing for~\itq{Transport Layer Security}, is a~widely used \hyperref[protocolstandard]{cryptographic protocol} describing the~certification mechanism on~the~\hyperref[internetweb]{web}.
You~can also meet the~abbreviation SSL, which stands for~\itq{Secure Sockets Layer}.
It's~a~predecessor of~TLS created in~1990s by~\href{https://en.wikipedia.org/wiki/Netscape}{Netscape}.
Although all versions of~the original SSL are~already deprecated and~Netscape is almost dead, the~abbreviation is still used.

When a~sender wants a~TLS certificate, he~must request it from~a~\hyperref[certificationauthority]{certification authority}\,--\,he~must send so~called \textit{certificate signing request}~(CSR) to~the~authority (and~of~course he~must~pay).
The~request is just a~file, typically with the~\itq{.csr} extension, which contains sender's public key and~some information about~him.
When the~authority verifies all the~information from~the~request (and~gets the~money), it~creates the~certificate, signs it with its private key (standard electronic signature described \hyperref[electronicsignature]{earlier}), appends the~signature to~the~certificate and~returns it to~the~sender.
Now~the~sender has a~valid certificate and~he~can~provide it to~receivers.
Receivers can~extract the~public key from the~certificate and~verify sender's signatures with~it.
They already have certificates from the~certification authority, so~if~they want to~verify the~sender's identity, they verify the~signature appended to~his~certificate using a~public key from the~certificate of~the~certification authority.

Certificates of~\hyperref[certificationauthority]{certification authorities} are~called root certificates and~they're stored in~so~called root stores, or~trusted stores.
These certificates are~self--signed\,--\,the~certification authority signs its certificate with its own private key.
Client programs (receivers) know root stores and~download root certificates from them.
Major root stores are~run by~Microsoft, Google, Mozilla or~Apple, because typical clients are~\hyperref[internetweb]{web} browsers, where the~TLS protocol is~used as~a~part of~the~\hyperref[https]{HTTPS protocol}.
All~the~certification authorities and~clients form so~called \itq{Public Key Infrastructure}~(PKI).

\newsubsection{Chain of Trust}
\index{Chain of trust}
\index{Intermediate certificate}
For~security reasons senders' certificates usually aren't signed directly by~private keys matching root certificates.
A~private key used for~signing a~sender's certificate usually matches only to~so~called intermediate certificate, which can~identify another 2nd \hyperref[certificationauthority]{certification authority} (but~can~be the~same) and~which can~be~signed by~another 3rd certification authority (still can~be the~same).
So~before accepting the~server certificate, the~client verifies the~intermediate certificate.
And~the~3rd certification authority also doesn't have to~be the~last one, its certificate can~be also only intermediate and~signed by~a~4th certification authority.
And~so~on.
Therefore, the~client must verify all~certificates in~this chain until it~reaches a~self--signed root certificate.

\newsubsection{X.509}
\index{X.509}
\label{x509}
It's~a~\hyperref[protocolstandard]{standard} defining the~format of~\hyperref[certificate]{certificates}.
It~describes compulsory parts of~a~certificate, like version, expiration date, public key information (including the~public key itself) or~the~certificate signature.
\hyperref[tls]{TLS},~and~therefore even \hyperref[https]{HTTPS}, follow this standard.

\newsubsection{TLS Certificate Formats}
Certificates are files.
They~can~exist in~a~simple text format similar to~\hyperref[yaml]{YAML}.
In~such~form all the~information is simply readable from the~certificate.

For~computer processing \hyperref[pem]{PEM formatting} is usually used.
Files with certificates in~this~format usually have \itq{.cert} or~\itq{.crt} extensions.

Certificates generally shouldn't contain private keys, but~some servers can~have stored their certificates and~private keys together in~one~file.
It's~possible to~have such combination stored in~the~\hyperref[pem]{PEM format} (the~private key is first, followed by~the~certificate), but~there's also an~unreadable file format following the~\hyperref[pkcs]{PKCS~\#12} standard.
Files in~this~format have extensions \itq{.pfx} or~\itq{.p12}.
They can~be even protected by~a~\hyperref[keypassword]{password}.

\newsection{Key VS Password}
\index{Key derivation function}
\index{KDF}
\index{Password}
\index{PBKDF}
\index{Password--Based Key Derivation Function}
\label{keypassword}
Fixed key lengths and~unprintability of~some byte values make direct usage of~keys difficult.
That's why the~concept of~passwords and~key derivation functions exists.
A~\textit{key derivation function} (KDF) is~an~one--way hashing function, that can~compute a~key of~a~desired byte length from a~string\,--\,password\,--\,of~any~length and~content.
Typical examples of~key derivation functions are~PBKDF1 and~PBKDF2 (\textit{Password--Based Key Derivation Function}), which are~mentioned in~the~\hyperref[pkcs]{PKCS~\#5} encryption standard.

\newsubsection{Usage in \hyperref[symmetriccryptography]{Symmetric Cryptography}}
When a~message is about to~be~encrypted, a~password is~provided by~the~sender and~a~key is~generated by~a~KDF\@.
When the~message is about to~be~decrypted, the~same password must~be provided by~the~receiver to~the~same KDF, which generates the~same key and~the~message can~be~decrypted.

\newsubsection{Usage in \hyperref[asymmetriccryptography]{Asymmetric Cryptography}}
In~\hyperref[asymmetriccryptography]{asymmetric cryptography} private keys are~sometimes protected by~passwords.
I.e.,~a~sender must provide a~password when \hyperref[electronicsignature]{signing} a~message and~a~receiver must provide a~password when \hyperref[asymmetriccryptography]{decrypting an~encrypted message}.

\newsection{Salt}
\index{Salt in cryptography}
\label{salt}
Salting is a~technique used as~hashing extension.
It~makes outputs of~a~hashing function different even when given the~same input more times.
It's~used mainly to~protect password--based systems, where hashes are~created from provided passwords
And~that's almost everywhere where passwords are~used.

Some random value, called \textit{salt}, is~incorporated to~the~original pre--hashed value.
It's~usually appended to~the~beginning or~to~the~end, but~even more complicated techniques of~embedding are~possible.
Such~value with the~incorporated salt is then given to~the~hashing function.
And~because the~salt is random, the~resulting hash is also random, i.e.,~always different.
The~original unhashed salt is then distributed with the~resulting hash.
When the~same hash should~be generated again, the~salt must~be incorporated to~the~same original input value.

This protects against brute force attacks, when an~attacker is~trying to~guess the~original value, has~precomputed hashes of~values common in~the~attacked area and~tries them one~by~one.
But~when the~value is salted, the~attacker first needs to~extract the~salt and~then compute hashes of~common values for~that particular case.
Computing hashes is a~costly operation, and~salting enforces to~do~it for~each single value.
In~other words, it~eliminates the~possibility of~computing hashes in~advance.

\newsubsection{Usage in \hyperref[keypassword]{Password--Based Cryptography}}
When a~key should~be generated from a~password by~a~key derivation function, salt is added to~the~password.
The~resulting key still always has the~desired length, but~is~always different.
The~salt must~be read during the~key generation and~stored somehow.
When the~key is needed again (message decryption, signature), the~provided password is~combined with the~stored salt and~the~used KDF generates the~correct key.

\newsubsection{Usage in \hyperref[authenticationauthorization]{Authentication and Authorization}}
Systems with password--protected user accounts need to~store users' passwords.
Storing them in~plain text, or~even just hashing them, is~an~obvious security risk.
Passwords are~therefore salted and~hashed and~these hashes are~stored together with salt.
When a~user wants to~log~in, he~provides his~username and~password, his~salt is~found in~the~system database, combined with the~password and~the~resulting hash is~verified.

\newsection{PKCS}
\index{PKCS}
\index{Public Key Cryptography Standards}
The~abbreviation stands for~\itq{Public Key Cryptography Standards}.
It's~a~set of~\hyperref[protocolstandard]{standards} for~various scenarios in~\hyperref[asymmetriccryptography]{asymmetric cryptography} created by \href{https://en.wikipedia.org/wiki/RSA_Security}{RSA~Security}.
You~will often encounter the~abbreviation with a~number, sometimes with hash tag.
This denotes one concrete \hyperref[protocolstandard]{standard} from~the~set.
Most important PKCS standards~are:
\begin{itemize}
    \itembfd{PKCS~\#1} first standard of~the~PKCS family, provides basic definitions~of and~recommendations for~implementing the~\hyperref[rsa]{RSA algorithm}.
             Defines mathematical properties of~public and~private keys, primitive operations for~encryption and~signatures, secure cryptographic schemes and~related syntax representations.
    \itembfd{PKCS~\#5} defines usage of~\hyperref[keypassword]{password--based encryption}.
    \itembfd{PKCS~\#8} defines handling of~private keys in~any~\hyperref[asymmetriccryptography]{asymmetric cryptography} algorithm.
             It~isn't fixed only to~the~\hyperref[rsa]{RSA~algorithm} (opposite to~PKCS~\#1).
    \itembfd{PKCS~\#12} defines an~archive file format for~storing many cryptography objects into a~single file, for~example, a~private key and~a~corresponding \hyperref[certificate]{certificate}.
\end{itemize}
