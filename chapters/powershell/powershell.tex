\newchapter{PowerShell}
\index{PowerShell}
\label{powershell}
PowerShell is Windows \hyperref[shellcligui]{CLI shell} with associated \hyperref[objectorientedprogramming]{object--oriented} \hyperref[scriptinglanguages]{scripting} programming language.

\newsection{CmdLets}
\index{CmdLet}
\label{cmdlet}
A~cmdLet (read as~\textit{command let}) is a~PowerShell console command in~the~pattern \mboxtextitquoted{Verb-Noun}. In~the~background a~cmdLet is a~\hyperref[dotnet]{.NET} class implementing a~particular operation. To~get a~list of~all available cmdLets run \textitquoted{Get-Command} (which itself is~a~cmdLet). The~complete list is~really long. If~you have some idea how~a~cmdLet can~be called, you~can~enclose the~approximate name to~asterisks to~filter the~complete list (\textitquoted{Get-Command *APPROXIMATE\_NAME*}).

When you know the~exact cmdLet name, you~can find~out more info about it by~using the~cmdLet \textit{Get-Help}, for~example, \textitquoted{Get-Help Get-Command}. It~works even with a~partial cmdLet name (and~even without asterisks), but~it~displays help fo~all matching cmdLets and~the~result is~much less verbose.

CmdLets are case--insensitive. Although almost all documentation describes them with first letters in~uppercase for~each word, even lowercase (or~any crazy combination of~uppercase and~lowercase letters) can~be used. This~is true even for~searching of~cmdLets and~getting help.

\newsubsection{Cmdlet VS PowerShell Script}
As~mentioned above, cmdLets are~\hyperref[dotnet]{.NET} classes. There's a~compiled implementation written in~some \hyperref[dotnet]{.NET} \hyperref[platform]{platform} language (C\#, Visual Basic,~\dots) behind a~cmdLet. On~the~other hand, PowerShell scripts are~written in~the~\hyperref[compiledinterpretedlanguages]{interpreted} PowerShell \hyperref[scriptinglanguages]{scripting language} and~can~be executed directly.

\newsection{Modules}
\index{Module}
\index{PowerShellGet}
\label{powershellmodule}
\hyperref[cmdlet]{CmdLets}, aliases, functions and~workflows are grouped to~modules. A~module is~a~collection of~such tools related to~a~common functional area. To~list all tools in~a~module run \textitquoted{Get-Command \mbox{-Module} MODULE\_NAME}. Modules can~be handled by~tools from~a~special module \textit{PowerShellGet} (see~further).

\newsection{Installing New Functionality}
\index{PowerShellGallery}
\index{PSGallery}
A~repository called \textit{PowerShellGallery} (sometimes abbreviated to~\textit{PSGallery}) is~available online by~default (custom repositories can~be created, but~that's too~complicated). With~functions from~the~\textit{PowerShellGet} module you~can~install and~update modules and~standalone scripts. You~can~also search for~all tools available for~installation. For~a~complete list of~available operations run \textitquoted{\mbox{Get-Command} \mbox{-module} PowerShellGet}.

\warning Run PowerShell as~administrator when installing new functionality. Otherwise, the~installation usually fails.

\newsubsection{Updating installed functionality}
There are \textit{Update} functions available in~the~\textit{PowerShellGet} module. Sometimes, however, an~old version of~the~updated module or~script remains installed in~the~computer and~active. To~solve this go~to~\textitquoted{Program Files/WindowsPowerShell} and~in~the~\textit{Modules} or~\textit{Scripts} delete all~files and~folders related to~the~old version.

\newsection{PackageManagement}
\index{PackageManagement}
\index{OneGet}
\label{windowspackagemanagement}
The~\textit{PackageManagement} (it really is called like this), formerly \textit{OneGet}, is a~\hyperref[powershellmodule]{PowerShell module} acting as~a~\hyperref[packagemanager]{package manager} for~Windows. It~isn't a~standard package manager. It~doesn't have own any package repository, it~uses repositories of~real Windows package managers and~enables to~use all such managers (which generally have various \hyperref[api]{APIs}) under one common~\hyperref[api]{API}. Some people say that PackageManagement is~a~package manager manager.

\warning Run PowerShell as~administrator when using the~PackageManagement. Otherwise, most~of its cmdLets don't work.

\newsubsection{Adding a~New Package Provider}
This means connecting a~repository of~a~Windows package manager to~your~PackageManagement. You~can~list currently connected providers by~\mboxtextitquoted{Get-PackageProvider} and~those available for~connection by~\mboxtextitquoted{Find-PackageProvider}. Sadly, you~can't explore a~repository in~PowerShell console until you connect it to~your PackageProvider. To~add a~provider run \textitquoted{Import-PackageProvider PROVIDER\_NAME}.

\newsubsection{Installing a~Package}
Find the~name of~the~package using the~\textit{Find-Package} cmdLet. You~can~use even an~approximate name enclosed to~asterisks (\textitquoted{\mbox{Find-Package} *APPROXIMATE\_NAME*}). You~must have a~provider offering the~package already registered. Then install the~package by~running \textitquoted{\mbox{Find-Package} PACKAGE\_NAME}.

\note You~can't~set a~location where the~application from~the~package is~installed~to. It's~always installed to~the~default location.

\warning The~most popular package manager for~windows\,--\,\href{https://chocolatey.org/}{Chocolatey}\,--\, doesn't work properly with PackageManagement. It~sometimes only downloads installation files, but~it~doesn't trigger the~installation itself. To~deal with~this install the~module, the~provider and~the~package \textit{ChocolateyGet} instead (three things with the~same name).
