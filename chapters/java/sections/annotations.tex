\newsection{Annotations}
\index{Annotation}
\index{Java annotation}
\label{javaannotation}
Annotations are~special labels by~components of~Java code denoted by~the~at~sign (\itq{@}).
They carry additional information -- metadata -- about components that they denote.
Although annotations have no direct effect on~the~annotated code operation, they're processed, either during compilation or~during runtime.
The~most typically used annotation is \hyperref[javaoverride]{\mbit{@Override}}.

\newsubsection{Custom Annotations}
\label{javacustomannotations}
Annotations aren't just fixed, developers can~create their own.
Annotation definition looks similar to~an~\hyperref[javainterface]{interface} definition.
The~key word stating that an~annotation is~defined is \mbitq{@interface} (with the~at~sign at~the~beginning).
Annotation classes can~contain method declarations (without a~body), which in~fact define annotation parameters.
These method headers are~always public and~can't~get an~\hyperref[javaaccessmodifiers]{access modifier}.
They can~be~followed by~the~keyword \mbitq{default} followed by~a~default value of~the~corresponding parameter.
The~default value type must match the~return type from the~method header.
If~a~parameter method doesn't have assigned default value, then the~parameter is~compulsory when using the~annotation.

Annotation usage and~behavior is~defined by~other, Java built--in annotations, sometimes called \textit{metaannotations}.
There are many of~them, but~only \mbitq{@Retention} and~\mbitq{@Target} are~necessary.

The~\mbit{@Retention} annotation defines if~the~custom annotation is~processed during compilation or~runtime.
It~gets one~of~values of~the~\mbitq{RetentionPolicy} enum.
There are only three possibilities:
\begin{itemize}
    \itembfd{RUNTIME} annotation is~processed during runtime.
    \itembfd{CLASS} annotation is~processed during compilation and~incorporated to~the~created \hyperref[javabytecode]{bytecode}.
    \itembfd{SOURCE} annotation is~processed during compilation and~is~\textbf{not}~incorporated to~the~created \hyperref[javabytecode]{bytecode}.
             I.e.,~the~annotation is~missing after eventual decompilation.
\end{itemize}

\noindent The~\mbit{@Target} annotation defines entities to~which the~custom annotation can~be applied.
It~gets one~or~more (enclosed in curly braces in~that~case) values of~the~\mbitq{ElementType} enum.
There are eleven possible values in~total.
They're quite self--explanatory, like \mbitq{METHOD} or \mbitq{FIELD}.
A~slight trap exists for~class annotations, where the~value is \mbitq{TYPE} \mbox{(not \mbitq{CLASS})}.

\warning Annotation classes don't support \hyperref[inheritance]{inheritance}.
Each~annotation class automatically extends (yes,~\textbf{extends}, not~\textit{implements}) the~Java built--in interface \mbitq{Annotation}, but~that's~all.
It~can't extend or~implement anything else, not~even another annotation class.
\newpage

\warning Although annotation definitions are much~closer to~interfaces (\mbitq{interface} in~the~keyword, methods without bodies, \textbf{extending} \mbox{the \itq{Annotation}} interface), those structures are still denoted as~annotation \textbf{classes}.

\newsubsection{Processing Annotations During Runtime}
This is relatively easy.
The~basic idea is to~get a~reference to~a~class with \hyperref[reflection]{reflection}, explore annotations of~its members or~the~class itself, and~when a~desired annotation is~detected, trigger some action.

\example
%! language = TEXT
\begin{lstlisting}[language=Java, title={Annotation processed during runtime, applicable to fields and methods}]
    @@>@Retention<@@(RetentionPolicy.RUNTIME)
    @@>@Target<@@({ElementType.FIELD, ElementType.METHOD})
    public @interface (*\tmnbf{annot1annot}{ExampleAnnotation}*) {
        String (*\tmnbf{annot1param}{exampleParameter}*)() default "example default value";
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Usage}]
    public class (*\tmnbf{annot1usageclass}{SimpleClass}*) {
        @>@(*\tmnbf{annot1usageannot1}{ExampleAnnotation}[LimeGreen]*)
        private String (*\tmnbf{annot1usagefield}{simpleField}*);

        @@>@(*\tmnbf{annot1usageannot2}{ExampleAnnotation}[LimeGreen]*)<@@((*\tmnbf{annot1usageparam}{exampleParameter}*) = "new value")
        public void simpleMethod() {
            ...
        }
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Runtime annotation processing}]
    Class<?> simpleClass = (*\tmnbf{annot1procclass}{SimpleClass}*).class;
    Field simpleField = simpleClass.getDeclaredField("(*\tmnbf{annot1procfield}{simpleField}[ForestGreen]*)");

    if (simpleField.isAnnotationPresent((*\tmnbf{annot1procannot1}{ExampleAnnotation}*).class)) {
        (*\tmnbf{annot1procannot2}{ExampleAnnotation}*) exampleAnnotation = simpleField.getAnnotation((*\tmnbf{annot1procannot3}{ExampleAnnotation}*).class);
        String exampleParameterValue = exampleAnnotation.(*\tmnbf{annot1procparam}{exampleParameter}*)();
        ...DO SOMETHING WITH THE PARAMETER VALUE...
    }
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{[xshift=3mm] annot1annot.south west}{annot1usageannot1.north}
    \drawarrow{[xshift=3mm] annot1annot.south west}{annot1usageannot2.north}
    \drawarrow{[xshift=3mm] annot1annot.south west}{[xshift=3mm] annot1procannot1.north west}
    \drawarrow{[xshift=3mm] annot1annot.south west}{annot1procannot2.north}
    \drawarrow{[xshift=3mm] annot1annot.south west}{[xshift=3mm] annot1procannot3.north west}
    \drawarrow{[xshift=-3mm] annot1param.south east}{[xshift=6mm] annot1usageparam.north}[red]
    \drawarrow{[xshift=-3mm] annot1param.south east}{[xshift=6mm] annot1procparam.north}[red]
    \drawarrow{[xshift=3mm] annot1usageclass.south}{[xshift=-3mm] annot1procclass.north}[green]
    \drawarrow{[xshift=6mm] annot1usagefield.south}{[xshift=3mm] annot1procfield.north west}[blue]
\end{tikzpicture}
\newpage

\newsubsection{Processing Annotations During Compilation}
That's much worse.
First, annotation must be already prepared in~the~compile time.
I.e.,~the~source code of~the~annotation class must be already compiled and~packed to~a~jar, which must be added to~classpath.
In~other words, you~must create the~annotation as~a~separate program (subproject is enough), pack it to~a~jar and~put it to~classpath.
Only then you~can~start writing the~code that uses the~annotation.

In~the~annotation program a~processor class must be created.
The~class must~be annotated with (repeatable) annotation \mbitq{@SupportedAnnotationTypes}, which specifies processed annotation class (or~classes), and~with annotation \mbitq{@SupportedSourceVersion}, which specifies minimal Java version under which the~processed annotation is~available during compilation.
The~class must also extend the~class \mbitq{AbstractProcessor} and~implement the~method \mbitq{process}.
The~method can~access annotated elements and~annotation values from its~parameters, namely from the~rounding environment, and~perform some action when a~desired annotation is~detected.

It's~desirable to~\hyperref[javaoverride]{override} the~\mbitq{init} method, retrieve the~processing environment messager in~it and~store the~messager to~a~global variable.
Interactions with the~compilation process (breaking compilation, printing warnings, \dots) in~the~\mbit{process} method are~then done through this messager, namely through its method \mbitq{printMessage}.
The~method can~take up~to~four parameters, but~only first two are~important:
\begin{itemize}
    \itembfd{Kind} a~member of~the~enum \mbitq{Diagnostic.Kind}.
             Specifies the~action to~perform.
             For~example, the~value \mbitq{ERROR} will~cause the~compilation to~fail.
    \itembfd{Message} character sequence (can~be string) with the~message to~display.
\end{itemize}
\noindent Nevertheless, it's~convenient to~use the~three--parameter version.
The~third parameter is~the~annotated element retrieved from the~\mbit{process} method parameters.
This~way the~element is~included to~printed information.

Additionally, the~jar must~be constructed so~that it~has a~file called exactly \mbitql{javax.;;annotation.;;processing.;;Processor} (without any further extension) inside the~\mbitql{META--INF/;;services} folder.
Inside this file there must~be package path to~the~processor class.
\newpage

\example
%! language = TEXT
\begin{lstlisting}[language=Java, title={Annotation processed during compilation, included in~compiled code, applicable to~fields and~methods}]
    package (*\tmnbf{annot2annotpkg}{annotationpackage}*);

    @@>@Retention<@@(RetentionPolicy.SOURCE)
    @@>@Target<@@({ElementType.FIELD, ElementType.METHOD})
    public @interface (*\tmnbf{annot2annot}{ExampleAnnotation}*) {
        String (*\tmnbf{annot2param}{exampleParameter}*)() default "example default value";
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Annotation processor, working from Java~8, failing when annotated element is encountered}]
    package (*\tmnbf{annot2procpkg}{processorpackage}*);

    @@>@SupportedAnnotationTypes<@@("(*\tmnbf{annot2procannotpkg}{annotationpackage}[ForestGreen]*).(*\tmnbf{annot2procannot1}{ExampleAnnotation}[ForestGreen]*)")
    @@>@SupportedSourceVersion<@@(SourceVersion.RELEASE_8)
    public class (*\tmnbf{annot2proc}{ExampleProcessor}*) extends AbstractProcessor {
        private Messager messager;

        @>@Override
        public synchronized void init(ProcessingEnvironment processingEnv) {
            messager = processingEnv.getMessager();
        }

        @>@Override
        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
            for (Element element: roundEnv.getElementsAnnotatedWith((*\tmnbf{annot2procannot2}{ExampleAnnotation}*).class)) {
                messager.printMessage(Diagnostic.Kind.ERROR, element.getAnnotation((*\tmnbf{annot2procannot3}{ExampleAnnotation}*).class). (*\tmnbf{annot2procparam}{exampleParameter}*)(), element);
            }
        }
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[title={The file \textit{javax.annotation.processing.Processor}}]
    (*\tmnbf{annot2fileprocpkg}{processorpackage}*).(*\tmnbf{annot2fileproc}{ExampleProcessor}*)
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{annot2annotpkg.south}{[xshift=6mm] annot2procannotpkg.north west}
    \drawarrow{[xshift=-3mm] annot2annot.south east}{annot2procannot1.north}[red]
    \drawarrow{[xshift=-3mm] annot2annot.south east}{annot2procannot2.north}[red]
    \drawarrow{[xshift=-3mm] annot2annot.south east}{annot2procannot3.north}[red]
    \drawarrow{annot2param.south}{[xshift=-3mm] annot2procparam.north}[green]
    \drawarrow{annot2procpkg.south}{annot2fileprocpkg.north}[blue]
    \drawarrow{[xshift=3mm] annot2proc.south}{[xshift=3mm] annot2fileproc.north}[Magenta]
\end{tikzpicture}
\newpage

\newsubsection{Parameter called \itq{value}}
\label{javaannotationparamvalue}
If~an~annotation contains only one parameter (method) called \mbitq{value}, it~isn't necessary to~specify the~parameter name when setting~it.
In~other words, it's~possible to~write directly the~value, without \mbox{the \itq{value = }} part.

\example
%! language = TEXT
\begin{lstlisting}[language=Java, title={Annotation with single parameter called \itq{value}}]
    @@>@Retention<@@(RetentionPolicy.RUNTIME)
    @@>@Target<@@(ElementType.METHOD)
    public @interface (*\tmnbf{annot3annot}{ExampleAnnotation}*) {
        String (*\tmnbf{annot3param}{value}*)() default "example default value";
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Setting the~parameter value~--~no~need to~write \mbitq{value = }}]
    public class (*\tmnbf{annot3usageclass}{SimpleClass}*) {
        @@>@(*\tmnbf{annot3usageannot}{ExampleAnnotation}[LimeGreen]*)<@@("new value")
        public void (*\tmnbf{annot3usagemethod}{simpleMethod}*)() {
            ...
        }
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Runtime annotation processing}]
    Class<?> simpleClass = (*\tmnbf{annot3procclass}{SimpleClass}*).class;
    Method simpleMethod = simpleClass.getDeclaredMethod("(*\tmnbf{annot3procmethod}{simpleMethod}[ForestGreen]*)");

    if (simpleMethod.isAnnotationPresent((*\tmnbf{annot3procannot1}{ExampleAnnotation}*).class)) {
        (*\tmnbf{annot3procannot2}{ExampleAnnotation}*) exampleAnnotation = simpleMethod.getAnnotation((*\tmnbf{annot3procannot3}{ExampleAnnotation}*).class);
        String exampleParameterValue = exampleAnnotation.(*\tmnbf{annot3procparam}{value}*)();
        ...DO SOMETHING WITH THE PARAMETER VALUE...
    }
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{annot3annot.south}{annot3usageannot.north}
    \drawarrow{annot3annot.south}{[xshift=-6mm] annot3procannot1.north}
    \drawarrow{annot3annot.south}{annot3procannot2.north}
    \drawarrow{annot3annot.south}{annot3procannot3.north}
    \drawarrow{annot3param.south east}{[xshift=3mm] annot3procparam.north west}[red][.3][bend left=5mm]
    \drawarrow{annot3usageclass.south}{annot3procclass.north}[green]
    \drawarrow{[xshift=6mm] annot3usagemethod.south}{annot3procmethod.north}[blue]
\end{tikzpicture}
\newpage

\newsubsection{Annotation as a Parameter of Other Annotation}
It~isn't possible to~create a~variable of~an~annotation class type and~assign something to~it.
You~can't write anything like \mbitqls{AnnotationClass;;;variableName;;;=;;;\dots}, because annotation classes can't be instantiated and~can't even have descendants.
However, it~\textbf{is} possible to~have annotation parameter (method) of~an~annotation class type and~assign a~corresponding annotation to~it.
It~makes sense only when the~inner assigned annotation has some parameters (without parameters it's~useless, but~possible).

\example
%! language = TEXT
\begin{lstlisting}[language=Java, title={Inner annotation}]
    @@>@Retention<@@(RetentionPolicy.RUNTIME)
    @@>@Target<@@(ElementType.FIELD)
    public @interface (*\tmnbf{annot4annot1}{InnerAnnotation}*) {
        String (*\tmnbf{annot4annot1param}{exampleParameter}*)() default "example default value";
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Outer annotation}]
    @@>@Retention<@@(RetentionPolicy.RUNTIME)
    @@>@Target<@@(ElementType.FIELD)
    public @interface (*\tmnbf{annot4annot2}{OuterAnnotation}*) {
        (*\tmnbf{annot4annot2annot1}{InnerAnnotation}*) (*\tmnbf{annot4annot2param1}{innerAnnotation}*)() default @@>@(*\tmnbf{annot4annot2annot2}{InnerAnnotation}[LimeGreen]*)<@@((*\tmnbf{annot4annot2param2}{exampleParameter}*) = "overridden default value");
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Usage}]
    public class SimpleClass {
        @@>@(*\tmnbf{annot4usageannot1}{OuterAnnotation}[LimeGreen]*)<@@((*\tmnbf{annot4usageparam1}{innerAnnotation}*) = @@>@(*\tmnbf{annot4usageannot2}{InnerAnnotation}[LimeGreen]*)<@@((*\tmnbf{annot4usageparam2}{exampleParameter}*) = "new value"))
        private String simpleField;
    }
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{[xshift=3mm] annot4annot1.south west}{annot4annot2annot1.north}
    \drawarrow{[xshift=3mm] annot4annot1.south west}{[xshift=-3mm] annot4annot2annot2.north}
    \drawarrow{[xshift=3mm] annot4annot1.south west}{[xshift=-3mm] annot4usageannot2.north}
    \drawarrow{[xshift=-3mm] annot4annot1param.south east}{annot4annot2param2.north}[red]
    \drawarrow{[xshift=-3mm] annot4annot1param.south east}{annot4usageparam2.north}[red]
    \drawarrow{annot4annot2param2.south}{annot4usageparam2.north}[red]
    \drawarrow{[xshift=3mm] annot4annot2.south west}{[xshift=-3mm] annot4usageannot1.north east}[green]
    \drawarrow{[xshift=-6mm] annot4annot2param1.south}{[xshift=-3mm] annot4usageparam1.north}[blue]
\end{tikzpicture}
\newpage

\noindent Using the~\hyperref[javaannotationparamvalue]{parameter called \mbitq{value}} is also possible:
%! language = TEXT
\begin{lstlisting}[language=Java, title={Inner annotation}]
    @@>@Retention<@@(RetentionPolicy.RUNTIME)
    @@>@Target<@@(ElementType.FIELD)
    public @interface (*\tmnbf{annot5annot1}{InnerAnnotation}*) {
        String value() default "example default value";
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Outer annotation}]
    @@>@Retention<@@(RetentionPolicy.RUNTIME)
    @@>@Target<@@(ElementType.FIELD)
    public @interface (*\tmnbf{annot5annot2}{OuterAnnotation}*) {
        (*\tmnbf{annot5annot2annot1}{InnerAnnotation}*) value() default @@>@(*\tmnbf{annot5annot2annot2}{InnerAnnotation}[LimeGreen]*)<@@("overridden default value");
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Usage}]
    public class SimpleClass {
        @@>@(*\tmnbf{annot5usageannot1}{OuterAnnotation}[LimeGreen]*)<@@(@@>@(*\tmnbf{annot5usageannot2}{InnerAnnotation}[LimeGreen]*)<@@("new value"))
        private String simpleField;
    }
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{annot5annot1.south}{annot5annot2annot1.north}
    \drawarrow{annot5annot1.south}{annot5annot2annot2.north}
    \drawarrow{annot5annot1.south}{annot5usageannot2.north}
    \drawarrow{[xshift=-3mm] annot5annot2.south}{annot5usageannot1.north}[red]
\end{tikzpicture}

\emten
\noindent Having \hyperref[javaarray]{array} of inner annotations is also possible:
%! language = TEXT
\begin{lstlisting}[language=Java, title={Inner annotation}]
    @@>@Retention<@@(RetentionPolicy.RUNTIME)
    @@>@Target<@@(ElementType.FIELD)
    public @interface (*\tmnbf{annot6annot1}{InnerAnnotation}*) {
        String value() default "example default value";
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Outer annotation}]
    @@>@Retention<@@(RetentionPolicy.RUNTIME)
    @@>@Target<@@(ElementType.FIELD)
    public @interface (*\tmnbf{annot6annot2}{OuterAnnotation}*) {
        (*\tmnbf{annot6annot2annot1}{InnerAnnotation}*)[] value() default {@@>@(*\tmnbf{annot6annot2annot2}{InnerAnnotation}[LimeGreen]*)<@@("overridden default value")};
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Usage}]
    public class SimpleClass {
        @@>@(*\tmnbf{annot6usageannot1}{OuterAnnotation}[LimeGreen]*)<@@({@@>@(*\tmnbf{annot6usageannot2}{InnerAnnotation}[LimeGreen]*)<@@("new value"), @@>@(*\tmnbf{annot6usageannot3}{InnerAnnotation}[LimeGreen]*)<@@("another value")})
        private String simpleField;
    }
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{annot6annot1.south}{annot6annot2annot1.north}
    \drawarrow{annot6annot1.south}{annot6annot2annot2.north}
    \drawarrow{annot6annot1.south}{annot6usageannot2.north}
    \drawarrow{annot6annot1.south}{[xshift=-3mm] annot6usageannot3.north}
    \drawarrow{[xshift=-3mm] annot6annot2.south}{[xshift=-3mm] annot6usageannot1.north east}[red]
\end{tikzpicture}
\newpage

\newsubsection{Nested Annotations}
\index{Nested Annotation}
