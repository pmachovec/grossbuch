\newsection{CommonJS}
\index{CommonJS}
\label{nodejscommonjs}
It's~Node.js native way of~separating code to~modules and~provide some sort of~\hyperref[objectorientedprogramming]{object--oriented programming}.
I.e.,~to~define and~use a~module in~CommonJS syntax you don't need any third party library in~Node.js, it~just works.

To~define a~module create a~JavaScript file containing (only) variables and~functions, i.e.,~no~code for~"immediate" execution.
At~the~end define a~handler for~each \hyperref[declarationdefinition]{definition} inside \mbit{module.exports} object.
It's~a~common practice to~call the~handler the~same as~the~handled entity.
Module members included in~the~\mbit{module.exports} object are~public members, others are~private.

To~load the~module in~a~different JavaScript file use the~\mbit{require} function with the~path to~the~module (without the~\itq{js} extension) as~the~\hyperref[parameterargument]{argument} and~assign the~result to~a~variable.
The~variable is~a~handler of~the~module.
By~calling module member handlers (defined previously in~the~\mbit{module.exports} object) on~the~module handler you~access individual members (functions and~variables) of~the~module.

\example{CommonJS module \hyperref[declarationdefinition]{definition} and~usage}
\enlargethispage{20mm}
\thispagestyle{empty}
%! language = TEXT
\begin{lstlisting}[language=JavaScript, title={Module file \mbit{\tmnbf{node1modfile}{moduleFile}.js}}]
    let (*\tmnbf{node1modvar1}{moduleVariable}*) = ...;

    function (*\tmnbf{node1modfunc1}{moduleFunction}*)() {
      ...
    }

    module.exports = {
      (*\tmnbf{node1modhand1}{moduleVariable}*): (*\tmnbf{node1modvar2}{moduleVariable}*),
      (*\tmnbf{node1modhand2}{moduleFunction}*): (*\tmnbf{node1modfunc2}{moduleFunction}*)
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=JavaScript, title={JavaScript executable file using the~module}]
    let moduleHandler = require('MODULE_FOLDER_PATH/(*\tmnbf{node1filefile}{moduleFile}[ForestGreen]*)');
    let simpleVar1 = moduleHandler.(*\tmnbf{node1filehand1}{moduleVariable}*); // Using module variable
    let simpleVar2 = moduleHandler.(*\tmnbf{node1filehand2}{moduleFunction}*)(); // Using module function
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{node1modfile.south}{node1filefile.north}
    \drawarrow{[xshift=-6mm] node1modvar1.south}{[xshift=-9mm] node1modvar2.north}[red]
    \drawarrow{[xshift=6mm] node1modfunc1.south}{[xshift=6mm] node1modfunc2.north}[green]
    \drawarrow{node1modhand1.south east}{node1filehand1.north west}[blue]
    \drawarrow{node1modhand2.south east}{node1filehand2.north west}[Magenta]
\end{tikzpicture}
\newpage

\note It's~possible and~recommended to~use \hyperref[amd]{AMD} modules and~\hyperref[requirejs]{RequireJS} implementation even in~Node.js.
The~code is~then eventually reusable in~a~\hyperref[internetweb]{web} browser and~it~retains the~effectiveness.
There are implementations of~CommonJS for~browsers (like the~RequireJS library), but~the~performance is~generally worse than RequireJS\@.
Also, RequireJS code has~better performance than CommonJS even directly in~Node.js (on~the~server side).

To~use RequireJS in~Node.js install it with \hyperref[npm]{NPM}.
You~can~then use the~RequireJS syntax for~loading other modules.
See~the~\hyperref[npmpackageusage]{NPM~packages usage section} for~an~example.
