\index{Spring framework}
\label{springframework}
It's a~Java framework created as an~alternative for~Java~EE, especially for~\hyperref[enterprisejavabeans]{EJB}, which were extremely slow and~hard to~implement in~their first versions (early 2000s). Although Java~EE has~been reworked and~can~do everything that Spring can, it~has so~bad reputation that Spring is still the~number one in enterprise applications development (\hyperref[internetweb]{web}~\hyperref[applicationprocessprogramservicethread]{services}, database access, messaging etc.).

\newsection{Spring Container}
\index{Spring container}
\index{Application context}
\label{springcontainrer}
It's~an~object factory handling \hyperref[inversionofcontrol]{inversion of~control} and~\hyperref[dependencyinjection]{dependency injection}. It's~also called \textit{application context}. It's~generally one~class, but~there~are more implementations provided.

\newsection{Inversion of Control}
\index{Inversion of control}
\index{Spring bean}
\label{inversionofcontrol}
It's~a~way of~creating objects with Spring containers. You~don't directly call constructors of~classes, instead you tell a~container what object (class instance) you want and~the~container will provide~it. The~purpose is to~achieve configurable code without a~need of~recompiling when a~behavior change is~needed.

Objects created by~Spring containers using the~inversion of~control are~called \textit{Spring~beans}. You~must provide implementations of~classes and~a~configuration for~a~container (XML, annotation, other class). Then~you instantiate a~container of~your choice and~give it the~configuration. The~configuration tells which class the~container will return when requested. And~finally you~request the~container to~give you the~instance\,--\,the~bean.

\warning Spring beans don't strictly follow restrictions of~\hyperref[javabeans]{Java beans}.

\warning When using the~XML configuration, the~XML file must~be located on~classpath when the~program is~executed. When you want to~execute the~program as~jar (fat~jar containing all~dependencies, at~least Spring libraries in~this case), it~must contain the~XML file on~the~same level as~the~top package (typically directly the~jar root). Furthermore, you~can't change the~program to~use some copy of~the~XML outside the~archive. Luckily, today's archive--operating software enables editing files inside archives, for~example the~7zip.

\example
\begin{lstlisting}[language=XML, title={Configuration XML}]
    <?xml version="1.0" encoding="UTF-8"?>
    <beans ...>
      <bean id="(*\tikzmarknodebf{ioc1xml1beanid}{wantedBeanId}[ForestGreen]*)" class="package.subfolder.WantedClass"/>
    </beans>
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Usage}]
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("configurationFile.xml");
    WantedClassInterface wantedClassInstance = context.getBean("(*\tikzmarknodebf{ioc1java1beanid}{wantedBeanId}[ForestGreen]*)", WantedClassInterface.class);
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{ioc1xml1beanid}{ioc1java1beanid}
\end{tikzpicture}

\noindent You can specify even more XML configuration files (or~even none at~all), the~constructor \textit{ClassPathXmlApplicationContext} accepts any~number of~(string) agruments (even zero).

Notice that the~only common thing of~the~XML and~the~Java code is the~bean~ID. The~wanted class is~specified only in~the~XML. In~the~Java code only the~interface, which the~class implements, is~used. The~class \textit{ClassPathXmlApplicationContext} comes from the~Spring package \textit{org.springframework.context.support}.

\note You~don't have to~always define and~use interfaces for~beans in~the~Java code. You~can use even the~class directly.
\begin{lstlisting}[language=XML, title={Configuration XML}]
    <?xml version="1.0" encoding="UTF-8"?>
    <beans ...>
      <bean id="(*\tikzmarknodebf{ioc2xml1beanid}{wantedBeanId}[ForestGreen]*)" class="package.subfolder.(*\tikzmarknodebf{ioc2xml1class}{WantedClass}[ForestGreen]*)"/>
    </beans>
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Usage}]
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("configurationFile.xml");
    (*\tikzmarknodebf{ioc2java1class}{WantedClass}*) wantedClassInstance = context.getBean("(*\tikzmarknodebf{ioc2java1beanid}{wantedBeanId}[ForestGreen]*)", (*\tikzmarknodebf{ioc2java1class2}{WantedClass}*).class);
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{ioc2xml1beanid}{ioc2java1beanid}
    \drawarrow{ioc2xml1class}{ioc2java1class}[red]
    \drawarrow{[xshift=6mm] ioc2xml1class.south}{ioc2java1class2}[green]
\end{tikzpicture}

\newsection{Dependency Injection}
\index{Dependency injection}
\index{Dependency}
\label{dependencyinjection}
Spring bean classes usually contain \hyperref[variablefieldproperty]{fields} of~some interface types. \hyperref[springcontainrer]{Spring container} assigns instances of~classes implementing those interfaces to~those fields. And~this assignment\,--\,injecting\,--\,is the~dependency injection.

Instances stored in fields are~called \textit{dependencies}. They mostly serve for~encapsulating configurable dynamic behavior of~Spring beans. The~configuration telling which bean should have assigned which dependency is a~part~of the~Spring configuration (XML, annotation, other class).

\note Dependencies are~also Spring beans.

\newsubsection{Constructor Injection}
\index{Constructor injection}
\label{constructorinjection}
One~of basic approaches to~the~dependency injection is to~set the~dependency via the~wanted class constructor. The~constructor must accept a~parameter of a~type of~an~interface, which is~implemented by the~dependency class. The~dependency class instance\,--\,another bean\,--\, is~specified and~injected to~the~wanted bean in~the~XML configuration file by~the~element \textit{constructor--arg}.

\example
\begin{lstlisting}[language=XML, title={Configuration XML}]
    <?xml version="1.0" encoding="UTF-8"?>
    <beans ...>
      <bean id="(*\tikzmarknodebf{di1xml1depbeanid}{dependencyBeanId}[ForestGreen]*)" class="package.subfolder.DependencyClass"/>
      <bean id="(*\tikzmarknodebf{di1xml1beanid}{wantedBeanId}[ForestGreen]*)" class="package.subfolder.(*\tikzmarknodebf{di1xml1class}{WantedClass}[ForestGreen]*)">
        <constructor-arg ref="(*\tikzmarknodebf{di1xml1depbeanid2}{dependencyBeanId}[ForestGreen]*)"/>
      </bean>
    </beans>
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Wanted class with the constructor}]
    private DependencyInterface dependencyField;

    public (*\tikzmarknodebf{di1java1class}{WantedClass}*)(DependencyInterface dependencyValue) {
        dependencyField = dependencyValue;
    }

    public WHATEVER (*\tikzmarknodebf{di1java1usedep}{useDependency}[ForestGreen]*)() {
        ...DO SOMETHING WITH THE DEPENDENCY FIELD...
    }
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Usage}]
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("configurationFile.xml");
    WantedClassInterface wantedClassInstance = context.getBean("(*\tikzmarknodebf{di1java2beanid}{wantedBeanId}[ForestGreen]*)", WantedClassInterface.class);
    wantedClassInstance.(*\tikzmarknodebf{di1java2usedep}{useDependency}*)();
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{di1xml1depbeanid}{di1xml1depbeanid2}
    \drawarrow{di1xml1beanid}{[xshift=-3mm] di1java2beanid.north}[red]
    \drawarrow{di1xml1class}{di1java1class}[green]
    \drawarrow{[xshift=3mm] di1java1usedep.south}{di1java2usedep}[blue]
\end{tikzpicture}

\newpage
\newsubsection{Setter Injection}
\index{Setter injection}
\label{setterinjection}
Another basic approach to~the~dependency injection is to~set the~dependency via a~setter method defined in~the~wanted class. The~wanted class must have a~zero--parameter constructor. It's~safer to~always define~it, even~if there is no other constructor (and~therefore the~zero--parameter one is~implicit). There~is nothing wrong with keeping the~constructor body empty. The~injection is~similar to~the~\hyperref[constructorinjection]{constructor} approach. The~dependency class instance\,--\,another bean\,--\, is~specified and~injected to~the~wanted bean in~the~XML configuration file by~the~element \textit{property}.

\warning There is one crucial restriction to~follow. The~\textit{property} element must contain the~attribute \textit{name} with some value, let's say \textit{someName}. The~name of~the~setter method in the~wanted class must then be exactly \textit{setSomeName}. The~name of~the~field variable doesn't matter.

\enlargethispage{1cm}
\example
\begin{lstlisting}[language=XML, title={Configuration XML}]
    <?xml version="1.0" encoding="UTF-8"?>
    <beans ...>
      <bean id="(*\tikzmarknodebf{di2xml1depbeanid}{dependencyBeanId}[ForestGreen]*)" class="package.subfolder.DependencyClass"/>
      <bean id="(*\tikzmarknodebf{di2xml1beanid}{wantedBeanId}[ForestGreen]*)" class="package.subfolder.(*\tikzmarknodebf{di2xml1class}{WantedClass}[ForestGreen]*)">
        <property name="(*\tikzmarknodebf{di2xml1depfield}{dependencyField}[ForestGreen]*)" ref="(*\tikzmarknodebf{di2xml1depbeanid2}{dependencyBeanId}[ForestGreen]*)"/>
      </bean>
    </beans>
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Wanted class with the zero--parameter constructor and the setter method}]
    private DependencyInterface dependencyField;

    public (*\tikzmarknodebf{di2java1class}{WantedClass}*)() {}

    public void set(*\tikzmarknodebf{di2java1depfield}{DependencyField}*)(DependencyInterface dependencyValue) {
        dependencyField = dependencyValue;
    }

    public WHATEVER (*\tikzmarknodebf{di2java1usedep}{useDependency}*)() {
        ...DO SOMETHING WITH THE DEPENDENCY FIELD...
    }
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Usage}]
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("configurationFile.xml");
    WantedClassInterface wantedClassInstance = context.getBean("(*\tikzmarknodebf{di2java2beanid}{wantedBeanId}[ForestGreen]*)", WantedClassInterface.class);
    wantedClassInstance.(*\tikzmarknodebf{di2java2usedep}{useDependency}[ForestGreen]*)();
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{di2xml1depbeanid}{di2xml1depbeanid2}
    \drawarrow{[xshift=-3mm] di2xml1beanid.north}{di2java2beanid}[red]
    \drawarrow{di2xml1class}{di2java1class}[green]
    \drawarrow{di2xml1depfield}{di2java1depfield}[blue]
    \drawarrow{[xshift=3mm] di2java1usedep.south}{di2java2usedep}[yellow][.5]
\end{tikzpicture}

\newsubsection{Injecting literal values}
\label{injectingliteralvalues}
You~can inject even values of primitive types and~strings directly. The~approach is the~same, but~instead~of using the~\textit{ref} attribute in~the~\textit{property} element you use the~\textit{value} attribute and~set directly the~value. You~can do it both for~\hyperref[constructorinjection]{constructor} and~\hyperref[setterinjection]{setter} injection.\\

\vspace{\baselineskip}
\noindent \textbf{Example\,--\,constructor injection:}
\begin{lstlisting}[language=XML, title={Configuration XML}]
    <?xml version="1.0" encoding="UTF-8"?>
    <beans ...>
      <bean id="(*\tikzmarknodebf{di3xml1beanid}{wantedBeanId}[ForestGreen]*)" class="package.subfolder.(*\tikzmarknodebf{di3xml1class}{WantedClass}[ForestGreen]*)">
        <constructor-arg value="someValue"/>
      </bean>
    </beans>
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Wanted class with the constructor}]
    private String concreteValueField;

    public (*\tikzmarknodebf{di3java1class}{WantedClass}*)(String concreteValue) {
        concreteValueField = concreteValue;
    }

    public WHATEVER (*\tikzmarknodebf{di3java1usevalue}{useConcreteValue}*)() {
        ...DO SOMETHING WITH THE CONCRETE VALUE FIELD...
    }
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Usage}]
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("configurationFile.xml");
    WantedClassInterface wantedClassInstance = context.getBean("(*\tikzmarknodebf{di3java2beanid}{wantedBeanId}[ForestGreen]*)", WantedClassInterface.class);
    wantedClassInstance.(*\tikzmarknodebf{di3java2usevalue}{useConcreteValue}*)();
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{di3xml1beanid}{di3java2beanid}
    \drawarrow{di3xml1class}{di3java1class}[red]
    \drawarrow{di3java1usevalue}{di3java2usevalue}[green]
\end{tikzpicture}
\newpage

\noindent \textbf{Example\,--\,setter injection:}
\begin{lstlisting}[language=XML, title={Configuration XML}]
    <?xml version="1.0" encoding="UTF-8"?>
    <beans ...>
      <bean id="(*\tikzmarknodebf{di4xml1beanid}{wantedBeanId}[ForestGreen]*)" class="package.subfolder.(*\tikzmarknodebf{di4xml1class}{WantedClass}[ForestGreen]*)">
        <property name="(*\tikzmarknodebf{di4xml1valuefield}{concreteValueField}[ForestGreen]*)" value="someValue"/>
      </bean>
    </beans>
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Wanted class with the zero--parameter constructor and the setter method}]
    private String concreteValueField;

    public (*\tikzmarknodebf{di4java1class}{WantedClass}*)() {}

    public void set(*\tikzmarknodebf{di4java1valuefield}{ConcreteValueField}*)(String concreteValue) {
        concreteValueField = concreteValue;
    }

    public WHATEVER (*\tikzmarknodebf{di4java1usevalue}{useConcreteValue}*)() {
        ...DO SOMETHING WITH THE CONCRETE VALUE FIELD...
    }
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Usage}]
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("configurationFile.xml");
    WantedClassInterface wantedClassInstance = context.getBean("(*\tikzmarknodebf{di4java2beanid}{wantedBeanId}[ForestGreen]*)", WantedClassInterface.class);
    wantedClassInstance.(*\tikzmarknodebf{di4java2usevalue}{useConcreteValue}*)();
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{di4xml1beanid}{di4java2beanid}
    \drawarrow{di4xml1class}{di4java1class}[red]
    \drawarrow{di4xml1valuefield}{di4java1valuefield}[green]
    \drawarrow{di4java1usevalue}{di4java2usevalue}[blue]
\end{tikzpicture}

\newsection{Reading values from \textit{.properties} files}
Files with the~\textit{.properties} extension are~popular approach for~dynamic applications configuration. They're simple text files in~which each line has the~form \textit{identifier=value}. When a~\textit{.properties} file is~added to a~Spring application \hyperref[classpath]{classpath}, it~can~be referenced in~the~Spring configuration file, as~well as values specified in~the~file.

The~\textit{.properties} file is~referenced in~the~element \textit{property--placeholder}, attribute \textit{location}, from the~\hyperref[namespaces]{namespace} \textit{\href{http://www.springframework.org/schema/context}{http://www.springframework.org/schema/context}}. The~convention is to~call this namespace as \textit{context} in the~XML file. The~name of~the~\textit{.properties} file in~the~attribute \textit{location} must~be preceded by the~part referring to~the~\hyperref[classpath]{classpath}, which~is literally "\textit{classpath:}" (with the~colon).

Values set in~the~\textit{.properties} file can be then referenced as attribute values, typically when \hyperref[injectingliteralvalues]{injecting literal values}, but~can~be used also as bean~IDs when injecting complex beans. A~concrete value is~accessed by~the~syntax~\textit{\$\{identifier\}}.

\warning Some IDEs (IntelliJ Idea for example) can~try to~"help" developers by~fake replacing the~dollar syntax with values from the \textit{.properties} file. I.e.,~it~looks like values are~specified directly in~the~XML file. The~indicator of~this "replacement" is that values have different color (gray in IntelliJ). If~you click on~such value, the~original dollar notation will appear.\\

\vspace{\baselineskip}
\noindent \textbf{Example\,--\,passing values to a constructor:}
\begin{lstlisting}[title={A \textit{.properties} file called \tikzmarknodebf{di5prop1filename}{\textit{constructor.properties}}}]
    (*\tikzmarknodebf{di5prop1intvalue}{intvalue}*)=1
    (*\tikzmarknodebf{di5prop1floatvalue}{floatvalue}*)=3.14
    (*\tikzmarknodebf{di5prop1stringvalue}{stringvalue}*)=String value
\end{lstlisting}
\begin{lstlisting}[language=XML, title={Configuration XML}]
    <?xml version="1.0" encoding="UTF-8"?>
    <beans ...
           xmlns:context="http://www.springframework.org/schema/context"
           ...>
      <(*\textcolor{blue}{context:}*)property-placeholder location="classpath:(*\tikzmarknodebf{di5xml1filename}{constructor.properties}[ForestGreen]*)"/>
      <bean id="someBeanId" class="package.subfolder.(*\tikzmarknodebf{di5xml1class}{WantedClass}[ForestGreen]*)">
        <constructor-arg value="(*\textcolor{ForestGreen}{\$\{}\tikzmarknodebf{di5xml1intvalue}{intvalue}[ForestGreen]\textcolor{ForestGreen}{\}}*)"/>
        <constructor-arg value="(*\textcolor{ForestGreen}{\$\{}\tikzmarknodebf{di5xml1floatvalue}{floatvalue}[ForestGreen]\textcolor{ForestGreen}{\}}*)"/>
        <constructor-arg value="(*\textcolor{ForestGreen}{\$\{}\tikzmarknodebf{di5xml1stringvalue}{stringvalue}[ForestGreen]\textcolor{ForestGreen}{\}}*)"/>
      </bean>
    </beans>
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Wanted class with the constructor}]
    private int intValueField;
    private float floatValuefield;
    private String stringValueField;

    public (*\tikzmarknodebf{di5java1class}{WantedClass}*)(int intValue, float floatValue, String stringValue) {
        intValueField = intValue;
        floatValueField = floatValue;
        stringValueField = stringValue;
    }

    public WHATEVER useValues() {
        ...DO SOMETHING WITH VALUE FIELDS...
    }
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{di5prop1filename}{[xshift=6mm] di5xml1filename.north}
    \drawarrow{di5prop1intvalue.south east}{[xshift=-6mm] di5xml1intvalue.north east}[red]
    \drawarrow{di5prop1floatvalue}{[xshift=-3mm] di5xml1floatvalue.north}[green]
    \drawarrow{[xshift=6mm] di5prop1stringvalue.south west}{di5xml1stringvalue.north west}[blue]
    \drawarrow{di5xml1class}{di5java1class}[yellow][.5]
\end{tikzpicture}
\newpage

\noindent \textbf{Example\,--\,passing values to setters:}
\begin{lstlisting}[title={A \textit{.properties} file called \tikzmarknodebf{di6prop1filename}{\textit{setters.properties}}}]
    (*\tikzmarknodebf{di6prop1intvalue}{intvalue}*)=1
    (*\tikzmarknodebf{di6prop1floatvalue}{floatvalue}*)=3.14
    (*\tikzmarknodebf{di6prop1stringvalue}{stringvalue}*)=String with spaces
\end{lstlisting}
\begin{lstlisting}[language=XML, title={Configuration XML}]
    <?xml version="1.0" encoding="UTF-8"?>
    <beans ...
           xmlns:context="http://www.springframework.org/schema/context"
           ...>
      <(*\textcolor{blue}{context:}*)property-placeholder location="classpath:(*\tikzmarknodebf{di6xml1filename}{setter.properties}[ForestGreen]*)"/>
      <bean id="someBeanId" class="package.subfolder.(*\tikzmarknodebf{di6xml1class}{WantedClass}[ForestGreen]*)">
        <property name="(*\tikzmarknodebf{di6xml1intvaluefield}{intValueField}[ForestGreen]*)" value="(*\textcolor{ForestGreen}{\$\{}\tikzmarknodebf{di6xml1intvalue}{intvalue}[ForestGreen]\textcolor{ForestGreen}{\}}*)"/>
        <property name="(*\tikzmarknodebf{di6xml1floatvaluefield}{floatValueField}[ForestGreen]*)" value="(*\textcolor{ForestGreen}{\$\{}\tikzmarknodebf{di6xml1floatvalue}{floatvalue}[ForestGreen]\textcolor{ForestGreen}{\}}*)"/>
        <propertu name="(*\tikzmarknodebf{di6xml1stringvaluefield}{stringValueField}[ForestGreen]*)" value="(*\textcolor{ForestGreen}{\$\{}\tikzmarknodebf{di6xml1stringvalue}{stringvalue}[ForestGreen]\textcolor{ForestGreen}{\}}*)"/>
      </bean>
    </beans>
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Wanted class with the zero--parameter constructor and setter methods}]
    private int intValueField;
    private float floatValuefield;
    private String stringValueField;

    public (*\tikzmarknodebf{di6java1class}{WantedClass}*)() {}

    public void set(*\tikzmarknodebf{di6java1intvaluefield}{IntValueField}*)(int intValue) {
        intValueField = intValue;
    }

    public void set(*\tikzmarknodebf{di6java1floatvaluefield}{FloatValueField}*)(float floatValue) {
        floatValueField = floatValue;
    }

    public void set(*\tikzmarknodebf{di6java1stringvaluefield}{StringValueField}*)(string stringValue) {
        stringValueField = stringValue;
    }

    public WHATEVER useValues() {
        ...DO SOMETHING WITH VALUE FIELDS...
    }
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{di6prop1filename}{di6xml1filename}
    \drawarrow{di6prop1intvalue.south east}{[xshift=-6mm] di6xml1intvalue.north east}[red]
    \drawarrow{di6prop1floatvalue}{[xshift=-3mm] di6xml1floatvalue.north}[green]
    \drawarrow{[xshift=6mm] di6prop1stringvalue.south west}{di6xml1stringvalue.north west}[blue]
    \drawarrow{di6xml1class}{di6java1class}[yellow][.5][bend left=12mm]
    \drawarrow{[xshift=-6mm] di6xml1intvaluefield.south}{di6java1intvaluefield}[Magenta]
    \drawarrow{[xshift=-4mm] di6xml1floatvaluefield.south}{di6java1floatvaluefield}[BurntOrange]
    \drawarrow{di6xml1stringvaluefield}{[xshift=3mm] di6java1stringvaluefield.north}
\end{tikzpicture}

\newsection{Bean Scope}
\index{Bean scope}
\index{Spring bean scope}
By default beans are singletons. That means whenever you call the~bean retrieval (\textit{context.getBean("wantedBeanId", ...)}), you~always get a~reference to~the same object. This~is OK when you~have stateless beans, it's memory--effective. However, when your beans holds some states in~their variables that affect their methods behavior, it~can~get pretty messy. For~this situation it's better to~always create a~new instance of~the~bean class. This~can~be achieved by~specifying the~attribute \textit{scope} with the~value \textit{prototype} in~the~\textit{bean} element.

\example
\begin{lstlisting}[language=XML, title={Configuration XML}]
    <?xml version="1.0" encoding="UTF-8"?>
    <beans ...>
      <bean id="someBeanId" class="package.subfolder.{WantedClass}" scope="prototype">
        ...
      </bean>
    </beans>
\end{lstlisting}

\note You can even specify the~singleton behavior by~\textit{scope="singleton"}, but~that's an~equivalent of~writing nothing, therefore, it's~useless.