\newchapter{Programming Language Categories}

\newsection{Compiled VS Interpreted Languages}
\index{Compiled language}
\index{Interpreted language}
\index{Compilation}
\index{Compiler}
\index{Interpreter}
\label{compiledinterpretedlanguages}
Each~source code in~any~language must~be somehow transferred to~a~machine code to~be~executed. This can~happen either as~a~separate step, or~directly as~a~part of~the~execution.

The~process of~transforming a~source code to~some more machine--readable code before its execution is~called \textit{compilation}. There's a~software called \textit{compiler} performing the~transformation. A~language processed by~a~compiler is~called \textit{compiled language}. The~result of~the~compilation can~be either directly the~machine code, or~some other, further processed form. For~example, \mbox{C~or~C++} are~compiled directly to~the~machine code. Because of~that a~special compiler is~needed for~each~\hyperref[platform]{platform} for~these languages. On~the~other hand, Java or~C\# are~compiled to~an~intermediate form, which must~be further transferred to~the~machine code, but~the~intermediate form can~be the~same for~all~\hyperref[platform]{platforms} (see~\hyperref[bytecode]{Java bytecode} for~example).

A~source code of~some languages can~be seemingly executed directly on~the~fly, without any compilation. Such languages are~called \textit{interpreted languages}. There's a~software called \textit{interpreter}, which transfers the~source code to~the~machine code and~executes~it immediately. For~each such language a~special interpreter is~needed for~each~\hyperref[platform]{platform}. Developing a~working \hyperref[applicationprocessprogramservicethread]{program} in~an~interpreted language is generally simpler than in~a~compiled language, but~programs written in~interpreted languages are~usually slower than~equivalents written in~compiled languages. Interpreted languages are~therefore more suitable for~writing smaller and~simpler programs, for~example, \hyperref[scriptinglanguages]{scripts}. Examples of~typical interpreted languages are JavaScript, \hyperref[powershell]{PowerShell} or~\hyperref[shbash]{Bash}.

\warning There is no pure compiled or~interpreted language. Compilation and~interpretation are just ways of~transforming some text following some syntax (i.e.,~a~source code) to~a~machine code. There can~theoretically exist both a~compiler and~an~interpreter for~any language.
\newpage

\newsection{Scripting Languages}
\index{Scripting language}
\label{scriptinglanguages}
There isn't an~exact definition what a~scripting language is, but~usually the~term denotes a~language, whose source code files\,--\,scripts\,--\,are~immediately available for~execution. I.e.,~it's~a~synonym for~an~\hyperref[compiledinterpretedlanguages]{interpreted language}.

A~scripting language always has a~special run--time environment (an~\hyperref[compiledinterpretedlanguages]{interpreter}) capable of~real time execution of~scripts. Scripting languages aren't limited to~only small scripts, even large and~complex programs can~be written in~them. Examples of~languages generally considered to~be scripting are~JavaScript, \hyperref[powershell]{PowerShell}, Python, Groovy, \hyperref[shbash]{Bash} or~VisualBasic.

Scripting languages are~popular for~tasks automation. A~developer writes a~script triggering multiple tasks. Then, instead~of executing each task separately, only the~script is~executed.

\newsubsection{Shebang}
\index{Shebang}
\index{Hashbang}
\label{shebang}
Scripts in~Linux systems sometimes contain a~special first line starting with hash sign and~exclamation mark (\textitquoted{\#!}), following a~name~of, or~full path~to, the~corresponding executing program. This line is~called \textit{shebang}, or~\textit{hashbang}. When the~script is~executed without specifying the~executor directly, \hyperref[os]{operating system} decides by~the~shebang what executor to~use. Shebang can~directly point to~a~specific program, or~can~tell the~system to~resolve the~path (the~executing program must~be included in~the~\textit{PATH} system variable). It~can~even contain switches.
\newline

\noindent \textbf{Examples:}
\begin{itemize}
    \item \textit{\#!/bin/sh} = \hyperref[shbash]{SH} symbolic link
    \item \textit{\#!/bin/bash -v} = \hyperref[shbash]{Bash}, direct path, verbose output
    \item \textit{\#!/usr/bin/env node} = \hyperref[nodejs]{Node.js}, resolved path
\end{itemize}
