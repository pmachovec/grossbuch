\newsection{Language Typing Systems}
Based on~how a~programming languages work with \hyperref[datatypes]{data types} of~their variables, they can~be divided to~statically and~dynamically typed and~to~strongly and~weakly typed.
That makes four categories in~total.
A~language exists for~each of~these categories.

\newsubsection{Statically VS Dynamically Typed Languages}
\begin{itemize}
    \itembf{Statically typed language} checks correctness of~data types before a~program can~be~executed, typically (but~not necessarily, see~further) during \hyperref[compiledinterpretedlanguages]{compilation}.
            As~a~compulsory part of~the~source code for~each variable it~must~be stated what type it~has.
            For~example, if~you~declare a~variable as~string and~then assign a~number to~it, your~program won't even start.
            Statically typed languages are~more time--consuming during development (the~code is~more verbose), but~programs are~generally faster, more stable and~easier to~debug.
    \itembf{Dynamically typed language} doesn't check correctness of~data.
            A~type of~a~variable is~decided at~program runtime based on~the~first assignment of~a~value to~that~variable.
            When later in~the~program some other type value is~assigned to~the~variable, the~program can (but~doesn't always have~to) fail.
            For~example, if~you~assign a~string to~a~variable and~then try to~multiply~it by~a~number, the~(running) program will~fail at~the~multiplication step.
            Source code is~easier to~write in~dynamically typed languages, but~programs are~generally slower, more unstable and~harder to~debug.
\end{itemize}

\warningnonl Usual definition of~statically typed languages says that the~type check is~performed during compilation.
This implies that languages, for~which an~\hyperref[compiledinterpretedlanguages]{interpreter} exist, can't~be statically typed, because there's no~compilation for~them.
However, this is not~necessarily true.
Although it's extremely rare, there can~be a~type check before interpreting, i.e.,~directly executing, a~source code.
Some variations of~Haskell do~this.

\newsubsection{Strongly VS Weakly Typed Languages}
\begin{itemize}
    \itembf{Strongly typed language} doesn't allow changes of~a~variable type.
            Once a~variable type is~decided, either before or~at~runtime, it's~fixed until the~program ends.
            For~example, consider a~dynamically typed language and~a~variable.
            At~first a~string is~assigned to~the~variable.
            When you~then try to~assign a~number to~it, the~program will~fail (at~runtime).
            Strongly typed languages are~more time--consuming during development, but~programs are~generally more stable and~easier to~debug.
    \itembf{Weakly typed language} allows variable type changes.
            Various values of~various types can~be assigned to~one~variable through a~program.
            Consider the~same example -- a~dynamically typed language and~a~variable.
            At~first a~string is~assigned to~the~variable.
            This time, when you try to~assign a~number to~it, the~original string will~be overridden by~the~number and~program will~continue running.
            Source code is~easier to~write in~weakly typed languages, but~programs can~behave unexpectedly and~are~harder to~debug.
\end{itemize}

\warning Although it~may~seem impossible, weakly statically typed languages do~exist, namely C and~C++.
In~these lower level languages each value is~treated as~a~bunch of~bytes.
Therefore, it's~possible to~assign, for~example, a~string to~a~variable declared as~integer.
Byte representation of~the~string is~then treated as~an~integer.
\newpage

\begin{table}[ht]
    \begin{adjustbox}{center}
        \renewcommand{\arraystretch}{1.4}
        \renewcommand{\arrayrulewidth}{1pt}
        \begin{NiceTabular}{c|l|l|}
            \CodeBefore
                \rectanglecolor{black!20}{1-2}{1-3} % First row background
                \rectanglecolor{black!20}{2-1}{10-1} % First column background
            \Body
                & \textbf{Statically typed languages} & \textbf{Dynamically typed languages} \\
                \hline
                \multirow{4}{*}{\textbf{Strongly typed languages}} & Java & Groovy \\
                    & Kotlin & Python \\
                    & C\# & Ruby \\
                    & Haskell & Erlang \\
                \hline
                \multirow{4}{*}{\textbf{Weakly typed languages}} & C & JavaScript \\
                    & C++ & PHP \\
                    & & VisualBasic \\
                    & & Perl
            \CodeAfter
                \tikz \draw[line width=1pt, black](2-|1) to (10-|1); % Left rule
                \tikz \draw[line width=1pt, black](1-|2) to (1-|4); % Top rule
                \tikz \draw[line width=1pt, black](10-|1) to (10-|4); % Bottom rule
        \end{NiceTabular}
    \end{adjustbox}
    \captit{Language examples for each typing system category}
\end{table}
