\newsection{Composition Over Inheritance}
\index{Composition}
\index{Composite reuse principle}
\label{compositionoverinheritance}
\hyperref[inheritance]{Inheritance}, although a~fundamental concept of~\hyperref[objectorientedprogramming]{OOP}, brings more problems than~use.
Many developers (allegedly even \href{https://en.wikipedia.org/wiki/James_Gosling}{James Gosling}, the~author of~Java) repeat the~mantra saying that \itq{inheritance is evil}.
To~address these problems the~principle of~composition over inheritance, also called \itq{composite reuse principle}, is~preferred.
Creating common functionality by this principle consists of~following steps:
\begin{itemize}
    \item Enforce the~common functionality by an~\hyperref[javainterface]{interface}.
    \item Make classes, which should contain the~common functionality, implementing the~interface.
    \item In~affected classes, delegate the~implementation to~some common descendant.
          The~descendant itself doesn't implement the~interface.
          It~should~be \hyperref[singletondp]{singleton}.
\end{itemize}

\noindent This approach deals with all~problems brought by inheritance:
\begin{itemize}
    \item \hyperref[abstraction]{Abstraction} isn't broken, because there's no ancestor implementation necessary to~know.
          Only an~interface is implemented, and~that generally doesn't contain an~implementation.
    \item When some common functionality isn't wanted in~a~class any~more, the~class can~simply stop implementing the~interface.
          The~unwanted common functionality then stops being enforced and~can~be removed.
          The~rest of~common functionality, which is still wanted, remains in~the~class.
    \item When there's a~problem with the~common code call, investigating downwards to~a~correct descendant is~much easier as~the~descendant class is clearly identifiable.
          Furthermore, logs and~stack traces identify the~problematic place more clearly.
\end{itemize}

\warning The~composite reuse principle doesn't follow the~\hyperref[compositedp]{composite design pattern}.
The~described structure is different.
\newpage

\enlargethispage{20mm}
\thispagestyle{empty}
\example[composition over inheritance in~Java]
%! language = TEXT
\begin{lstlisting}[language=Java, title={Common functionality enforcing interface}]
    public interface EnforcingInterface {
        void commonFunctionality();
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={First class to~contain common functionality}]
    public class FirstClass implements EnforcingInterface {
        private final CommonFunctionalityDescendant theDescendant;

        public FirstClass() {
            theDescendant = CommonFunctionalityDescendant.getDescendant();
        }

        @>@Override
        public void commonFunctionality() {
            theDescendant.commonFunctionalityImplementation()
        }
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Second class to~contain common functionality}]
    public class SecondClass implements EnforcingInterface {
        private final CommonFunctionalityDescendant theDescendant;

        public SecondClass() {
            theDescendant = CommonFunctionalityDescendant.getDescendant();
        }

        @>@Override
        public void commonFunctionality() {
            theDescendant.commonFunctionalityImplementation()
        }
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={\hyperref[singletondp]{Singleton} descendant containing the~common functionality implementation}]
    public class CommonFunctionalityDescendant {
        ...SINGLETON STUFF...

        public static CommonFunctionalityDescendant getDescendant() {
            ...RETURN THE SINGLETON INSTANCE...
        }

        public void commonFunctionalityImplementation() {
            ...
        }
    }
\end{lstlisting}
