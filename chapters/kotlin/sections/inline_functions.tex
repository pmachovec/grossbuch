\newsection{Inline Functions}
\index{Inline}
\hyperref[kotlinanonymousfunction]{Anonymous functions}, including \hyperref[kotlinlambda]{lambda functions}, have one rather unpleasant characteristic.
When~you~call a~function of~higher order, which~takes another function as~a~parameter, the~compilation resulting \hyperref[javabytecode]{bytecode} corresponds to~Java code creating an~implementation of~a~special interface type \mbitq{FunctionX}[,] where~the~\mbitq{X}[is] a~number corresponding to~the~number of~parameters of~the~parameter function.
The~code of~the~passed parameter function is embedded in~the~implementation of~the~function \mbitq{invoke} from~the~\mbit{FunctionX} interface.

\example
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Function of higher order}]
    class HighClass {
        ...
        // Parameter function has two parameters.
        fun higherOrderFunction(parameterFunction: (Int, String) -> WHATEVER) {
            ...
            // Executing the parameter function.
            parameterFunction(0, "Something")
            ...
        }
        ...
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Calling the~function of higher order}]
    fun doSomething()
        val highClass = HighClass()

        highClass.higherOrderFunction { intParam, stringParam ->
            ...DO SOMETHING...
        }
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Rough Java equivalent of the generated bytecode}]
    public class Function2Subclass0 implements Function2<Integer, String> {
        public static final Function2 INSTANCE = new Function2Subclass0(0, "Something");
        ...
        @>@Override
        public static void invoke() {
            ....DO SOMETHING...;
        }
        ...
    }
    ...
    public class HighClass {
        ...
        public void higherOrderFunction(@@>@NotNull<@@ Function2 parameterFunction) {
            parameterFunction.invoke();
        }
        ...
    }
    ...
    public static void doSomething() {
        HighClass highClass = new HighClass();
        highClass.higherOrderFunction(Function2Subclass0.INSTANCE);
    }
\end{lstlisting}

\noindent I.e.,~for~each~unique passed callback function a~new~instance of~\mbit{FunctionX} is~created and~one~extra call of~the~function \mbitq{invoke} is~performed.
And~that causes additional \hyperref[systemmemory]{memory} consumption, runtime overhead and~slowing down the~running program.

If~the~passed function captures a~member of~its~closure (accesses a~variable from~the~enclosing structure), it's~even worse.
In~such~case, an~\hyperref[javaanonymousclass]{anonymous implementation} of~the~\mbit{FunctionX} interface is~generated on~each~higher order function call, which~means even more new~\mbit{FunctionX} instances --~one~per~call.

\example
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Higher order function accessing a member of its closure}]
    fun doSomething() {
        ...
        val simpleValue = "something"
        ...
        val highClass = HighClass()

        highClass.higherOrderFunction { intParam, stringParam ->
            ...DO SOMETHING WITH simpleValue...
        }
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Rough Java equivalent of the generated bytecode}]
    public static void doSomething() {
        ...
        String simpleValue = "something";
        ...
        HighClass highClass = new HighClass();
        highClass.higherOrderFunction(new Function2<Integer, String>() {
            ...DO SOMETHING WITH simpleValue...;
        });
    }
\end{lstlisting}
\newline

\noindent And~that's~where inlining comes to~the~rescue.
A~function can~be declared with~the~keyword \mbitq{inline}[.]
The~generated bytecode then~corresponds to~having the~function body directly instead of the~function call.
I.e.,~at~the~place, where~the~original code calls the~function, the~bytecode contains commands from~inside that~function.
Calls~of~parameter functions are~replaced with~passed callback bodies.
There's no~new~object instantiation nor~extra function~call.

\example
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Inlined function of higher order}]
    class HighClass {
        ...
        inline fun higherOrderFunction(parameterFunction: (Int, String) -> WHATEVER) {
            ...BEFORE...
            parameterFunction(0, "Something")
            ...AFTER...
        }
        ...
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Calling the~inline function}]
    fun doSomething {
        ...
        val simpleValue = "something"
        ...
        val highClass = HighClass()

        highClass.higherOrderFunction { intParam, stringParam ->
            ...DO SOMETHING WITH simpleValue...
        }
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Rough Java equivalent of the generated bytecode}]
    public static void doSomething() {
        ...
        String simpleValue = "something";
        ...
        HighClass highClass = new HighClass();
        ...BEFORE...;
        ...DO SOMETHING WITH simpleValue...;
        ...AFTER...;
    }
\end{lstlisting}

\noindent Note that the~class containing the~higher order function \mbox{(\textit{HighClass})} is~instantiated, but~not~used.
It~doesn't cause any~performance degradation, the~instance would~be created anyway.
Without~it, the~performance would~be~better, but~it~can't~be prevented because of the~Kotlin compiler nature --~there's instantiation in~the~original code, and~that~results in~instantiation in~the~bytecode.
Put~up with~it.

Although inline functions may~seem like a~way to~go all~the~time at~the~first glance, it~shouldn't~be overused.
There~are~several drawbacks to~consider.

\begin{itemize}
    \item They~cause the~bytecode to~grow.
          If~a~function body is~large, a~careful consideration of~(not)~inlining the~function based on~the~expected function usage must~be~done.
    \item They~don't~see members of~their holding structures (classes, objects) with~lower visibility modifiers.
          E.g.,~public inline function can't~use private members of~its~class.
    \item They~can't~be mocked in~unit tests, because the~compiled bytecode doesn't actually contain them.
          I.e.,~they make code testing more complicated.
    \item When a~higher order function is~inline, all~its parameter functions must~be either executed directly in~that~function body, or~passed further to~another inline function.
          When~passed further to~a~not~inline function, the~compilation will~fail (see~\hyperref[kotlinoinline]{\mbit{noinline}} and~\hyperref[kotlincrossinline]{\mbit{crossinline}} for~workarounds).
\end{itemize}

\note Even first order functions --~without parameter functions --~can~be declared with the~\mbitq{inline} keyword, but~that's~considered to~be a~bad~practice.
It~only causes the~bytecode to~grow, there's no~performance enhancement.
Some IDEs show a~warning when~you try~to~declare something like~that.

\newsubsection{Non--local Return}
\index{Non--local return}
\index{Non--local control flow}
\index{Control flow}
\label{kotlinnonlocalreturn}
This is a~very tricky feature, which~you may~come across especially at~Kotlin job interviews.
In~general, using the~\mbitq{return} keyword isn't allowed in~\hyperref[kotlinlambda]{lambda functions}, the~return value is simply the~value of~the~last command in~the~function body.
If~you~need to~return from~a~lambda earlier, you~must~use \hyperref[kotlinreturnatlabel]{returning at~labels}.
If~you try~to~use \mbitq{return} in~a~lambda function as~standalone, the~compilation will~fail.
However, there's one case when~the~\mbitq{return} keyword can~appear as~standalone in~a~lambda.
And~that~is when~the~lambda is~passed as~an~argument to~an~inline function.
The~lambda must~be written directly to~the~call of~the~higher order function.
When~stored to~a~variable first, the~compilation will~still fail.

But~that~isn't the~only trick.
Another one is the~expected returned value type.
Because of~the~nature of~inlining, the~lambda code is like written at~the~call place of~the~higher order function, i.e.,~it's~like writing \mbitq{return} at~that~place.
And~that~means the~return is~treated as~belonging to~the~function containing the~call place, i.e.,~the~returned value type must~be the~return type of~that~function.

\example
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Parameter function returns String}]
    class HighClass {
        ...
        inline fun higherOrderFunction(parameterFunction: (...) -> String) {
            ...
            val stringResult = parameterFunction(...)
            ...
        }
        ...
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Function returns Int}]
   fun doSomething: Int {
        ...
        val highClass = HighClass()

        // The higher order function is inline.
        highClass.higherOrderFunction { ... ->
            ...
            if (SOMETHING IS WRONG) {
                // This return belongs to "doSomething" => Int
                return -1
            }
            ...
            // Return value of the lambda => String
            "something"
        }
    }
\end{lstlisting}

\note When~the~passed callback isn't in~the~lambda format, everything works without any~surprise.
Using the~\mbitq{return} keyword is~possible, it~returns the~value of~the~callback and~the~function can~be even stored to~a~variable first.
But~it~also means you~can't~use \mbox{the non--local} return even if~you~want, not~even with~\hyperref[kotlinreturnatlabel]{returning at~labels}.

\example
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Higher order function call with standard anonymous function}]
   fun doSomething: Int {
        ...
        val highClass = HighClass()

        // The higher order function is inline.
        highClass.higherOrderFunction(fun(): String {
            ...
            // No way how to make "doSomething" return -1
            ...
            return "something"
        })
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Equivalent with the function stored in a variable}]
   fun doSomething: Int {
        ...
        val parameterFunction = fun(): String {
            ...
            // No way how to make "doSomething" return -1
            ...
            return "something"
        }

        val highClass = HighClass()
        highClass.higherOrderFunction(parameterFunction)
    }
\end{lstlisting}

\note \mbox{Non--local} return is the~cause why~parameter functions of~inline higher order functions can't~be passed further to~not~inline functions.
If~that was~possible, it~could~result in~a~return statement in~a~lambda function passed to~a~not~inline function --~the~lambda would~be passed first to~the~inline function \mbox{(that's OK),} but~then to~the~not~inline (that's forbidden).

\newsubsection{Noinline}
\index{Noinline}
\label{kotlinoinline}
By~default, all~passed callbacks are~propagated to~the~holding function calling point as~shown above when~the~higher order function is~inline.
When~you don't~want that to~happen for~certain parameter functions, you~can~use the~keyword \mbitq{noinline} for~corresponding parameters in~the~function header.
And~you~typically don't~want that when~it~causes the~compilation to~fail, i.e,~when~the~parameter function is~passed further to~a~not~inline function.
But~you can~prevent inlining for~any~parameter of~a~\hyperref[kotlinanonymousfunction]{function type} (for~other types the~keyword is~forbidden).

\example
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Classes with functions of higher order}]
    class HighClass {
        ...
        inline fun higherOrderFunction(
            parameterFunction: (Int, String) -> WHATEVER,
            noinline anotherParameterFunction: (Boolean) -> WHATEVER
        ) {
            ...
            parameterFunction(0, "Something")
            ...
            // Passing parameter function to not inline function.
            val anotherHighClass = AnotherHighClass()
            anotherHighClass(anotherParameterFunction)
        }
        ...
    }

    class AnotherHighClass {
        fun notInlinedHigherOrderFunction(anotherParameterFunction: (Boolean) -> WHATEVER) {
            ...
            anotherParameterFunction(true)
            ...
        }
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Calling the~inline function}]
    fun doSomething {
        ...
        val highClass = HighClass()

        highClass.higherOrderFunction({ intParam, stringParam ->
            ...DO SOMETHING...
        }, { boolParam ->
            ...DO SOMETHING MORE...
        })
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Rough Java equivalent of the generated bytecode}]
    public static void doSomething() {
        ...
        String simpleValue = "something";
        ...
        HighClass highClass = new HighClass();
        ...DO SOMETHING...;

        // Not inline parameter function is processed in the standard way.
        AnotherHighClass anotherHighClass = new AnotherHighClass();
        anotherHighClass.notInlinedHigherOrderFunction( Function1Subclass0.INSTANCE);
    }
\end{lstlisting}

\note As~parameter functions with~the~\mbitq{noinline} modifier can't~be inline, it's~impossible to~use \hyperref[kotlinnonlocalreturn]{\mbox{non--local} returns} when~defining callbacks in~the~lambda format.

\newsubsection{Crossinline}
\index{Crossinline}
\label{kotlincrossinline}
You~may~encounter a~situation when~you~must pass a~parameter function from~an~inline function further to~a~not~inline function (e.g.,~when~using third party libraries).
You~can~use the~\mbitq{\hyperref[kotlinoinline]{noinline}} keyword, but~then~you~loose the~performance enhancement of~inlining, because the~parameter function will~be~executed in~the~standard way --~with~new~object instances and~extra function calls.
Luckily, the~inlining can~be applied even to~those not~inline functions under certain conditions.

Passing of~functional parameters from~inline functions further to~not~inline is forbidden only because of \hyperref[kotlinnonlocalreturn]{\mbox{non--local} returns}, there's absolutely no other reason.
Therefore, if~you~guarantee that~a~parameter function doesn't~contain \mbox{a non--local} return, it~should be possible.
And~that's what~the~\mbitq{crossinline} keyword serves~for.
If~you~mark a~parameter function with~this~keyword, the~compilation won't~allow \hyperref[kotlinnonlocalreturn]{\mbox{non--local} returns} when~defining a~callback for~it.
And~when the~callback surely doesn't~contain \mbox{a non--local} return, it's~safe to~inline even the~not~inline function.

\example[filtering a list of strings by a special function]
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Special function for filtering in a standalone library}]
    package somepackage

    // The function is not inline.
    fun checkFilterForItem(
        theItem: String,
        filterFunction: (String) -> Boolean
    ): Boolean {
        ...SOMETHING...
        return filterFunction(theItem)
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Passing callback from inline function to not inline}]
    import somepackage.checkFilterForItem

    class StringListFilter {
        inline fun filterList(
            theList: List<String>,
            crossinline filterFunction: (String) -> Boolean
        ): List<String> {
            val resultList = mutableList<String>()

            theList.forEach {
                if (checkFilterForItem(it, filterFunction) {
                    resultList.add(it)
                }
            }
        }
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Calling the~inline function}]
    fun doSomething {
        ...
        val theList = listOf(...)
        val stringListFilter = StringListFilter()

        stringListFilter.filterList(theList) {
            it.length >= 5
        }
    }
\end{lstlisting}
%! language = TEXT
\begin{lstlisting}[language=Java, title={Rough Java equivalent of the generated bytecode}]
    public static void doSomething() {
        ...
        List<String> theList = ...;

        // Not used instance of StringListFilter
        StringListFilter stringListFilter = new StringListFilter();

        List<String> resultList = new ArrayList<>();

        for (String it: theList) {
            // Even the code of the not inline function is inlined.
            ...SOMETHING...

            if (it.length() >= 5) {
                resultList.add(it);
            }
        }
    }
\end{lstlisting}
