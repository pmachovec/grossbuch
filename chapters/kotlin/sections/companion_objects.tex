\newsection{Companion Objects}
\index{Companion object}
\label{kotlincompanionobject}
It's~an~\hyperref[kotlinobject]{object} defined inside a~standard class.
It~doesn't have own name, it's~just a~code block labeled as \itq{companion object}.
Fields and~functions defined inside a~companion object can~be~accessed over the~main class, like \hyperref[javastatic]{static} members in~Java.
Companion objects basically represent those special instances created by~Java for~\hyperref[javastatic]{static} members.

\example[class with companion object]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    class ClassWithCompanionObject {
        companion object {
            lateinit var simpleValue: String
        }
    }

    ClassWithCompanionObject.simpleValue = "SOMETHING"
\end{lstlisting}

\note Class members outside a~companion object can't~access members of~the~companion object.
This prevents unwanted overriding of~the~singleton instance fields.

\newsubsection{Overloading the \textit{invoke} operator}
It~is~possible to~\hyperref[kotlininvokeoverload]{overload the~\mbit{invoke} operator} in~a~companion object.
And~this can~create a~conflict with~a~constructor.
In~that~case the~program uses the~constructor and~ignores the~overloaded operator.
I.e.,~it~doesn't fail.

\example[\textit{invoke} operator overloaded in a companion object]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    class ClassWithCompanionObject(...CONSTRUCTOR_STUFF...) {
        companion object {
            operator fun invoke(...CONSTRUCTOR_STUFF...) {
                ...NOT_CALLED...
            }
        }
    }

    // This doesn't call the code of the overloaded operator
    ClassWithCompanionObject(...)
\end{lstlisting}
\newline
