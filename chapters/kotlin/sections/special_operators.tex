\newsection{Special Operators}
\newsubsection{Safe Call (?.)}
\index{Safe call}
\label{kotlinsafecall}
Alternative for~the~standard dot notation.
Can~be~used on~variables of~nullable types.
If~the~variable isn't null, the~safe call calls the~referenced function or~property on~the~type instance stored in~the~variable.
Otherwise, it~returns null.
It~doesn't throw an~exception.

\example[variable is not null]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val first: String? = "first"
    val result: String? = first?.reversed() // result is "tsrif"
\end{lstlisting}

\example[variable is null]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val first: String? = null
    val result: String? = first?.reversed() // result is null
\end{lstlisting}

\newsubsection{Non--null assertion (!!)}
Kotlin code aims to~avoid a~null pointer exception as~much as~possible.
Values must~be explicitly assigned to~non--nullable type variables, calls on~nullable type variables must~be done with the~\hyperref[kotlinsafecall]{safe call}~etc.
If~there's a~possibility to~hit a~null pointer, the~compilation fails.

\mbox{The~non--null} assertion operator can~be~used on~a~nullable type variable to~suppress the~null safety mechanism.
By~using the~operator the~code author asserts that he's aware of the~null possibility.
It~can~be~used in~an~assignment or~with the~dot notation.
When the~asserted variable is null, using the~operator results \mbox{in \textit{KotlinNullPointerException}.}
\newpage

\example[usage in assignment]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val nullable: String? = "nullable"
    // val nonNullable String = nullable // Not compilable
    val nonNullable: String = nullable!!
\end{lstlisting}

\example[usage in dot notation]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val nullable: String? = "nullable"
    val result: String = nullable!!.reversed()
\end{lstlisting}

\example[causing exception]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val nullable: String? = null
    val nonNullable: String = nullable!! // KotlinNullPointerException
\end{lstlisting}

\newsubsection{Elvis Operator (?:)}
\index{Elvis operator}
Two--value operator written in~the~infix notation.
Returns the~left side argument if~it~isn't null.
Otherwise, returns the~right side argument, even when it's null.
I.e.,~it's coalesce operator for~two values.

\example[no~argument is null]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val first: String? = "first"
    val second: String? = "second"
    val result: String? = first ?: second // result is "first"
\end{lstlisting}

\example[first argument is null]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val first: String? = null
    val second: String? = "second"
    val result: String? = first ?: second // result is "second"
\end{lstlisting}

\example[second argument is null]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val first: String? = "first"
    val second: String? = null
    val result: String? = first ?: second // result is "first"
\end{lstlisting}

\example[both arguments are null]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val first: String? = null
    val second: String? = null
    val result: String? = first ?: second // result is null
\end{lstlisting}
\newpage

\newsubsection{Reflection (::)}
\index{Reflection}
\index{Bound class reference}
\index{Callable reference}
\label{kotlinreflection}
Two--value operator written in~the~infix notation.
Used to~retrieve entities of~the~reflection API in~Kotlin.
Basic usage is with~a~class name on~the~left side, allowing access references of~that class.
Can~be also used with a~variable on~the~left side, in~that case it~gets references of~the~type class of~that variable.
This is called \itq{bound class reference}.

\example[retrieving instances of (classes implementing) the~interface \textit{KClass}]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    // Variable type is KClass<String>
    val basicRef String::(*class*)

    // Variable type is KClass<KClass<String>>
    val boundRef = basicStringRef::(*class*)
\end{lstlisting}
\newline

\noindent When used without the~class name on~the~left side, it~gets references to~the~current class.

\example[accessing reference to the current class]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    class SimpleClass {
        // Variable type is KClass<SimpleClass>
        val thisRef = ::(*class*)
    }
\end{lstlisting}
\newline

\noindent When used with a~function name on~the~right side (with~or~without a~class name on~the~left side, that~doesn't matter), it~returns that~function (not~its return value, the~function isn't executed).
It's~like having the~function written as~\hyperref[kotlinanonymousfunction]{anonymous} and~stored in~a~variable.
This is called \itq{callable reference}.

\example[getting callable reference to a function]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    class SimpleClass {
        // Type of the function is (Unit) -> SOME_TYPE
        fun doSomething() : SOME_TYPE {
            ...
        }
    }

    // Type of the variable is (Unit) -> SOME_TYPE
    val callRef = SimpleClass::doSomething
\end{lstlisting}
\newpage

\noindent Can~be also used to~retrieve references to~class properties.
It~also works in~the~bound format~--~with a~variable on~the~left side.

When used with a~class name on~the~right side (and~with empty left side), it~returns a~reference to~the~class constructor.
Constructors are also functions and~can~be referenced with~the~reflection.

\example[getting constructor reference]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    class SimpleClass {
        ...
    }

    val constRef = ::SimpleClass
\end{lstlisting}
