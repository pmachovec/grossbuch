\newsection{Coroutines}
\index{Coroutine}
\label{kotlincoroutine}
Kotlin provides a~library (not~a~part of~the~core) for~handling \hyperref[concurrentparallelasynchronous]{asynchronous programming} as~\hyperref[coroutines]{coroutines}.
It's~an~alternative to~"good" old \hyperref[coroutines]{threads}, which~are expensive and~hard to~maintain, and~also to~various \hyperref[reactiveprogramming]{reactive programming} approaches (Future, Promise, RxKotlin), which~are~generally good, but~with~large amount of~functions for~various situations and~therefore hard to~use.
Also, reactive programming tools tend to~have poor to~no documentation, making their usage even harder.

\warning Some sources, including official Kotlin web, claim that passing functions as~parameters to~other functions (i.e.,~callbacks) can~provide asynchronous behavior.
But~that's not~true.
If~you just pass a~function as~callback and~do nothing else \mbox{(no new} \mbox{thread etc.)}, the~code will~wait for~everything to~finish.
What~follows the~called wrapping function is~executed only after that function and~all passed callbacks finish their execution.

\warning It's~important to~realize that, opposite to~threads, you~can't~hold a~reference to~a~coroutine, there's nothing like \mbit{Coroutine} class.
You~only can~have references to~various objects related to~a~concrete coroutine.

\newsubsection{Scope}
\index{Scope}
\index{Coroutine scope}
\label{kotlincoroutinescope}
Kotlin coroutine is just a~sequence of~commands.
We~say that these commands run in~the~scope of~that~coroutine.
If~a~command in~a~coroutine scope creates another coroutine, then the~new coroutine also runs in~the~scope of~the~original coroutine.
This~way, coroutines are~organized in~a~parent--child hierarchy.
When~a~coroutine is terminated (reaches the~end, fails~etc.), even its descendant coroutines are terminated.

There's an~interface \mbit{CoroutineScope}.
Each~coroutine has~assigned an~instance of~a~specific implementation of~this interface based on the~coroutine type, allowing to~manipulate with~the~scope programmatically.
The~scope of~a~coroutine is typically created automatically and~made accessible inside the~coroutine's \hyperref[kotlincoroutinebuilder]{builder}.
However, it's~possible to~create one in~advance with~the~factory function \mbit{CoroutineScope} and~use a~builder with~it (see~further for~examples).

\newsubsection{Context}
\index{Context}
\index{Coroutine context}
\label{kotlincoroutinecontext}
It's~a~collection of~various elements related to~one coroutine.
Each~\hyperref[kotlincoroutinescope]{scope} contains a~corresponding context in~the~property \mbit{coroutineContext} of~the~type of~\mbit{ CoroutineContext} interface.
Each~element is an~instance of~some extension of the~\mbit{Element} interface.
The~context itself is a~map, where~keys are~formed by classes extending the~\mbit{Element} interface.

For~example, coroutines can~have names.
There's the~class \mbit{CoroutineName} (extending the~\mbit{Element} interface over multiple steps) holding the~name inside the~property \mbit{name}[.]
To~retrieve the~name (the~string) from~a~context, you~use something like \mbitqls{val theName;;;=;;;theContext[CoroutineName];;?.name} (the~map output is nullable, because there's no warranty that~the~context contains any~name).

The~\mbit{CoroutineContext} interface \hyperref[kotlinoperatoroverload]{overloads the~\textit{plus} operator} so~that it's~possible to~join two~contexts to~one with~it.
If~joined contexts contain a~same key, the~conflict is resolved in~favor of~the~other one, i.e.,~the~one on~the~right side of~the~\textit{plus} operator.

To~make everything even more confusing, the \textit{Element} interface extends the~\mbit{CoroutineContext} interface.
I.e.,~a~context is de~facto a~collection of~contexts.
This~is because of~the~already mentioned \hyperref[kotlincoroutinescope]{\mbit{CoroutineScope}} factory function.
The~function takes a~context as~its parameter.
With \textit{Element} extending \mbit{CoroutineContext}, it's~possible to~pass a~standalone element.
And~because of the~overloaded \textit{plus} operator, it's~possible to~pass multiple elements joined by the~operator.
Context elements, which~aren't passed, but~are~necessary, are~set to~default values automatically.

\example[various context operations]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    // Creating two scopes with coroutine names
    val firstScope = CoroutineScope(CoroutineName("First"))
    val secondScope = CoroutineScope(CoroutineName("Second"))

    // Joining two contexts
    val contextJoin = firstScope.coroutineContext + secondScope.coroutineContext
    println(contextJoin[CoroutineName]?.name) // Will print "Second"

    // Creating scope of the join with fixed name
    val scopeJoin = (
        firstScope.coroutineContext
        + secondScope.coroutineContext
        + CoroutineName("Joined") // Must be last to override previous
    )
\end{lstlisting}

\newsubsection{Builders}
\index{Builder}
\index{Coroutine builder}
\label{kotlincoroutinebuilder}
A~coroutine must be created by one of~special functions from~the~coroutines library.
These functions are~called \textit{coroutine builders}.
They take a~parameterless callback function as~the~last (but~not~necessarily the~only) parameter, and~commands inside this callback are~commands run in~the~created coroutine scope.
It's~convenient to~pass the~callback function in~the~\hyperref[kotlinlambda]{lambda format}.
There are three coroutine builders --~\mbit{runBlocking}[,] \mbit{launch} and~\mbit{async}.

Coroutine builders are~defined so that the~corresponding instance of~\mbit{CoroutineScope} is available in~the~callback function body under the~\mbit{this} keyword --~the~callback \hyperref[kotlinanonymousreceivertype]{receiver type} is declared to~be \mbit{CoroutineScope}[.]
When~running program executes the~callback function --~the~coroutine body --~it~passes a~scope instance to~it.

\newsubsection{\textit{runBlocking}}
\index{RunBlocking}
\label{kotlincoroutinerunblocking}
It's~the~only builder not~declared as~an~\hyperref[kotlinextension]{extension} of~\textit{CoroutineScope}.
Because of~this, it~can~be simply imported and~called anywhere, just as~it~is.
It's~something like a~bridge between simple top--down executed code and~asynchronously executed code in~coroutines.
It~doesn't produce any asynchronous behavior, commands inside its callback are~simply executed on~the~same thread where~the~builder was~called, respecting their order.
However, the~callback is treated as~a~full-value coroutine with~a~scope.
It's~used to~start other coroutines by other builders.
Such~coroutines then~run in~the~scope of~the~coroutine created by the~\mbit{runBlocking} builder.
It~blocks its thread until all descendant coroutines aren't finished.
Opposite to~other builders, it~can~also return a~value from~the~callback.

\example[\textit{runBlocking}]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    import kotlinx.coroutines.runBlocking

    fun runOnMainThread() {
        ...

        val runBlockingResult = runBlocking {
            ...
            "result" // Returning a value from the callback
        }

        println(runBlockingResult) // Will print "result"
    }
\end{lstlisting}

\newsubsection{\textit{launch}}
\index{Launch}
\label{kotlincoroutinelaunch}
It~suspends the~code in~the~callback so~that it's~executed later when~a~thread is~free.
By~default, it~doesn't produce a~new~thread.
The~code just waits until the~current thread is released (see~\hyperref[kotlincoroutinedispatcher]{dispatchers} for~assigning another thread), that~is, when~the~outer block is~completed.

For~example, when~used inside \mbit{runBlocking}, all~commands of the~\mbit{runBlocking} are~executed first and~only after that commands of the~\mbit{launch} are~executed.
When~executed inside another \mbit{launch}, then~commands of~the~outer \mbit{launch} are~executed first.
And~when there~are multiple such \mbit{launch} hierarchies, higher levels are~executed first.

In~these situations --~calling inside another parent builder --~the~\mbit{launch} builder is~called on~the~parent \mbit{CoroutineScope} instance available in~the~enclosing callback of~the~parent builder.
Most of parent context members are~inherited to~the~child context (but~not~all, see~\hyperref[kotlincoroutinejob]{jobs}).

\example[two--level \textit{launch} followed by another inside \textit{runBlocking}]
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Numbers represent the~order of~execution}]
    import kotlinx.coroutines.launch
    import kotlinx.coroutines.runBlocking

    fun runOnMainThread() {
        ...1...

        runBlocking { // CoroutineScope instance available as "this"
            ...2...

            // Launch on the first level
            launch { // Equivalent of "this.launch {..."
                ...4...

                // Launch on the second level
                // Waits for all first level commands to finish
                launch {
                    ...8...
                }

                ...5...
            }

            // Another launch on the first level
            launch {
                ...6...

                // Another launch on the second level
                launch {
                    ...9...
                }

                ...7...
            }

            ...3...
        }

        ...10...
    }
\end{lstlisting}
\newline

\noindent If~you~have a~\mbit{\hyperref[kotlincoroutinecontext]{Context}} instance, you~can~pass it to~the~\mbit{\hyperref[kotlincoroutinescope]{CoroutineScope}} factory function and~call the~builder on~the~result.
This construction occurs mainly with~\hyperref[kotlincoroutinedispatcher]{dispatchers} and~multiple threads.
Be~aware that when~you~do this on~a~main program thread, it~can~reach its end before processing the~builder callback.
In~that~case, the~callback won't~be executed.

\example[\textit{launch} called on standalone simple scope]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    import kotlinx.coroutines.CoroutineScope
    import kotlinx.coroutines.launch

    fun runOnMainThread() {
        // Primitive scope with only coroutine name in the context
        CoroutineScope(CoroutineName("Simple name")).launch {
            // This won't be reached.
        }
    }

    // Something like "Thread.sleep" here would release the thread and the callback would run.

    // END OF THE MAIN THREAD
\end{lstlisting}
\newline

\noindent Kotlin coroutines library also provides the~object \mbit{GlobalScope}, which~is basically some general scope with~a~general context, and~it's~possible to~call builders on~it.
However, this should~be rather avoided.

\example[\textit{launch} called on \textit{GlobalScope}]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    import kotlinx.coroutines.GlobalScope
    import kotlinx.coroutines.launch

    fun runOnMainThread() {
        GlobalScope.launch {
            // This won't be reached.
        }
    }

    // Something like "Thread.sleep" here would release the thread and the callback would run.

    // END OF THE MAIN THREAD
\end{lstlisting}

\warning If~you~construct a~scope inside \mbit{runBlocking}, the~\mbit{runBlocking} won't wait for~coroutines triggered on~that~new scope.
Such~coroutines don't belong to~the~scope of the~\mbit{runBlocking}[.]

\example[\textit{launch} called on new scopes inside \textit{runBlocking}]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    runBlocking {
        CoroutineScope(CoroutineName("Simple name")).launch {
            // This won't be reached.
        }

        GlobalScope.launch {
            // This won't be reached.
        }
    }
\end{lstlisting}

\note The~\mbit{runBlocking} builder waits for~all~previously suspended code waiting to~be~run on~the~same thread.
And~it~can~be even the~main program thread.
Because of~that, when~you~construct a~standalone scope, create a~coroutine on~it and~then~use unrelated \mbit{runBlocking}, the~coroutine will~be completed before the~\mbit{runBlocking} starts.

\example[\textit{launch} called on standalone simple scope followed by \textit{runBlocking}]
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Numbers represent the~order of~execution}]
    import kotlinx.coroutines.GlobalScope
    import kotlinx.coroutines.launch

    fun runOnMainThread() {
        CoroutineScope(CoroutineName("Simple name")).launch {
            ...1...
        }

        runBlocking {
            ...2...
        }
    }
\end{lstlisting}

\newsubsection{\textit{async}}
\index{Async}
\index{Deferred}
\label{kotlincoroutineasync}
The~\mbit{async} builder basically works in~the~same way as~\mbit{launch}.
The~difference is that, when~called, it~returns an~instance (of~a~class implementing) the~interface \mbit{Deferred}.
This~instance provides the~function \mbit{await}, which, when~called, stops the~parent coroutine at~that~place and~performs the~builder callback.
Then~the~parent coroutine run continues.
I.e.,~instead of letting the~parent coroutine to~reach the~end end before starting its own run, it~starts its run at~the~specific moment of~the~parent coroutine~run.

\example[simple \textit{async} inside \textit{runBlocking}]
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Numbers represent the~order of~execution}]
    import kotlinx.coroutines.async
    import kotlinx.coroutines.runBlocking

    fun runOnMainThread() {
        runBlocking {
            ...1...

            val deferredInstance = async {
                ...3...
            }

            ...2...
            deferredInstance.await()
            ...4...
        }
    }
\end{lstlisting}

\example[\textit{async} inside \textit{launch} inside \textit{runBlocking}]
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Numbers represent the~order of~execution}]
    import kotlinx.coroutines.async
    import kotlinx.coroutines.launch
    import kotlinx.coroutines.runBlocking

    fun runOnMainThread() {
        runBlocking {
            ...1...

            launch {
                ...3...

                val deferredInstance = async {
                    ...5...
                }

                ...4...
                deferredInstance.await()
                ...6...
            }

            ...2...
        }
    }
\end{lstlisting}

\example[\textit{launch} inside \textit{async} inside \textit{runBlocking}]
%! language = TEXT
\begin{lstlisting}[language=Kotlin, title={Numbers represent the~order of~execution}]
    import kotlinx.coroutines.async
    import kotlinx.coroutines.launch
    import kotlinx.coroutines.runBlocking

    fun runOnMainThread() {
        runBlocking {
            ...1...

            val deferredInstance = async {
                ...3...

                launch {
                    ...5...
                }

                ...4...
            }

            ...2...
            deferredInstance.await()
            ...6...
        }
    }
\end{lstlisting}
\newline

\noindent The~\mbit{Deferred} instance returned by the~function \mbit{await} can~return a~value.
The~interface real signature is \mbitq{Deferred<out T>}, where the~\mbitq{T} represents the~return type.
The~\mbit{await} function then~returns a~value of this type~\mbitq{T}.
The~return value is specified in the~\mbit{async} callback as~in~any other \hyperref[kotlinlambda]{lambda function} --~written on~the~last line without the~\mbit{return} keyword.

\example[\textit{await} returning a value]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    import kotlinx.coroutines.async
    import kotlinx.coroutines.runBlocking

    fun runOnMainThread() {
        runBlocking {
            ...

            val deferredInstance = async {
                ...
                "something"
            }

            ...
            // The result will be "something".
            val result = deferredInstance.await()
            ...
        }
    }
\end{lstlisting}
\newline

\warning Having the~\mbit{await} function blocking the~run at~a~desired place, it~may~seem unnecessary to~enclose~it to a~\mbit{runBlocking} callback (or~another builder callback).
At~the~first glance, constructing a~standalone scope, invoking \mbit{async} on~it and~run \mbit{await} later looks feasible.
However, this is not~possible.
The~\mbit{await} function is so~called \hyperref[kotlinsuspendfunction]{suspended function}, which~means it~can~be called only from~a~coroutine (i.e.,~from~a~builder callback) or~from~another suspended function.
If~you~try to~use it outside, the~compilation will~fail.

\example[attempt to have \textit{async/await} outside builder callbacks]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val deferredInstance = CoroutineScope(...).async {
        ...
    }

    // Will cause compilation error.
    deferredInstance.await()
\end{lstlisting}

\warning All~three coroutine builders can~take a~\mbit{Context} instance as~a~parameter.
When~used, almost every time an~element from~the~given context sets or~overrides the~same element, which~would~be otherwise inherited from~the~parent coroutine context or~set to~a~default value.
But~this doesn't hold every time.
There's a~malicious behavior with~\hyperref[kotlincoroutinejob]{jobs} and~\hyperref[kotlincoroutinedispatcher]{dispatchers} (see~corresponding sections).
However, it's~convenient for~setting simple coroutine characteristics like, for~example, the~coroutine name.

\example[setting coroutine names by builders]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    runBlocking(CoroutineName("Outer bridge")) {
        ...

        launch(CoroutineName("Real coroutine")) {
            ...
        }

        ...
    }
\end{lstlisting}

\newsubsection{Suspended functions}
\index{Suspend}
\label{kotlinsuspendfunction}
This is probably the~most confusing feature of~Kotlin coroutines.
You~can~declare a~function with~the~keyword \mbitq{suspend}.
With~that done, the~function will~be callable only from~a~coroutine (i.e.,~from~a~builder callback) or~from~another function declared as~suspended.

\example[suspended function]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    import kotlinx.coroutines.async
    import kotlinx.coroutines.runBlocking

    fun runOnMainThread() {
        runBlocking {
            launch {
                suspendedFun()
            }
        }

        // Will cause compilation error.
        suspendedFun()
    }

    private suspend fun suspendedFun() {
        ...
    }
\end{lstlisting}
\newline

\noindent Remember!
It's~only a~marker, by~which the~function author is saying that~the~corresponding function does something, which~can~freeze current thread for~some time (it~doesn't~have to~be~true), and,~therefore, should~be run asynchronously.
Although documentations, tutorials and~(wannabe) experts say otherwise, it~has \textbf{absolutely no effect} on how~the~function, the~enclosing coroutine, or~even the~whole program, \mbox{behave.}

There are some functions in~the~coroutines library which~are declared as~suspended.
And~basically the~only situation when~you~must declare your function as~suspended is when~your function calls some of~those functions from~the~library.
Otherwise, when~using your~function inside a~coroutine, the~code will~work exactly the~same with~or~without the~\mbit{suspend} modifier.
Some \mbox{IDEs} will~even mark the~modifier as~redundant when~not~calling another suspended function.
Even~those suspended functions from~the~coroutines library could~be rewritten without~the~modifier.
Very~base functions from~deep down of~the~library, doing \mbox{"the magic"} by primitive operations (declared as~suspended), would~also have the~modifier marked \mbox{as redundant}.

Some sources say not~to~declare a~function as~suspended, unless the~compiler forces you to~do~so.
That~is, unless you need to~call a~suspended function from~the~coroutines \mbox{library.}

When~you implement some expensive operations, like big files processing, database handling or~network communication, you~can~declare your functions suspended even standalone.
This~will~make your~function more idiot--proof when~used by someone else --~he~will have~to wrap your~function call to~a~coroutine.
Most likely you~will, however, have~to put~up with~your IDE complaining about the~redundant \mbox{modifier.}

\warning The~idiocy resistance of~suspended functions has~one weak spot -- the~\mbit{\hyperref[kotlincoroutinerunblocking]{runBlocking}} builder.
The~\mbit{runBlocking} callback is treated as~a~valid coroutine, therefore, it's~possible to~call a~suspended function from~it.
But~the~callback also runs sequentially within other code.
Because of~that, when~the~suspended function really does something blocking the~thread, and~when~called directly from a~\mbit{runBlocking} callback, it~will~block the~main \mbox{thread.}

\example[wrong usage of suspended function]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    import kotlinx.coroutines.async
    import kotlinx.coroutines.runBlocking

    fun runOnMainThread() {
        runBlocking {
            // Will cause the program to stuck.
            suspendedFun()
        }
    }

    private suspend fun suspendedFun() {
        ...LONG EXPENSIVE COMPUTATION...
    }
\end{lstlisting}

\newsubsection{\textit{withContext}}
\index{WithContext}
It's~a~\hyperref[kotlinsuspendfunction]{suspended function} to~be~used inside a~coroutine when~you~need some code block to~be~completed before proceeding with~the~coroutine computation.
The~code block is~best to~be~passed in~the~\hyperref[kotlinlambda]{lambda format}, it~can~even return a~value, which~is~returned by the~\mbit{withContext} function itself, similarly like when~returning a~value from~\mbit{\hyperref[kotlincoroutinerunblocking]{\textit{runBlocking}}}[.]
Beside the~callback it~also requires some \hyperref[kotlincoroutinecontext]{context} instance.
The~callback block runs in~the~\hyperref[kotlincoroutinescope]{scope} of~the~enclosing coroutine, but~with~a~different context created by joining the~original coroutine context and~the~one passed.
Conflicting values take precedence from~the~given new~context.

\newsubsection{\textit{coroutineScope}}
\index{CoroutineScope}

\newsubsection{Jobs}
\index{Job}
\label{kotlincoroutinejob}
Each~coroutine has~assigned a~job of~the~interface type~\mbit{Job}.
A~coroutine's job is a~handle to~the~coroutine life cycle, mainly for~its monitoring, but~can~be also used for~partial coroutine run control.

Life cycle of~a~coroutine is monitored by three Boolean properties --~\mbit{isActive}, \mbit{isCompleted} and~\mbit{isCancelled}.
Combinations of~values of~these properties define various coroutine states.

\begin{table}[ht]
    \begin{adjustbox}{center}
        \renewcommand{\arraystretch}{1.4}
        \renewcommand{\arrayrulewidth}{1pt}
        \begin{NiceTabular}{|lr|M{25mm}|M{25mm}|M{25mm}|}
            \CodeBefore
                \rowcolor{yellow!50}{1} % First row background
                \columncolor{yellow!50}{1-2} % First multicolumn background
            \Body
                \hline
                {\fontsize{10}{10}\selectfont\textbf{State}}
                    & {\fontsize{10}{20}\selectfont\raisebox{1mm}{\textbf{Property}}}
                    & \itbf{isActive}
                    & \itbf{isCompleted}
                    & \itbf{isCancelled} \\
                \hline
                \multicolumn{2}{|l|}{\itbf{new} (optional initial state)} & false & false & false \\
                \hline
                \multicolumn{2}{|l|}{\itbf{active} (default initial state)} & true & false & false \\
                \hline
                \multicolumn{2}{|l|}{\itbf{completing} (transient state)} & true & false & false \\
                \hline
                \multicolumn{2}{|l|}{\itbf{cancelling} (transient state)} & false & false & true \\
                \hline
                \multicolumn{2}{|l|}{\itbf{cancelled} (final state)} & false & true & true \\
                \hline
                \multicolumn{2}{|l|}{\itbf{completed} (final state)} & false & true & false
            \CodeAfter
                \tikz \draw[line width=1pt, black](1-|1) to (2-|3); % Diagonal rule in the top left cell
                \tikz \draw[line width=1pt, black](8-|1) to (8-|6); % Bottom rule
        \end{NiceTabular}
    \end{adjustbox}
\end{table}

\notenonl Yes,~\textit{active} and~\textit{completing} states have identical property values and~can't~be distinguished.
When the~combination of~values is reached, it's~always considered to~be the~\textit{active} state.
The~\textit{completing} state exists purely for~confusion.
\newline

\noindent A job is an~element of~the~corresponding \hyperref[kotlincoroutinecontext]{coroutine context}.
Beside retrieving it by the~map syntax (\mbitq{theContext[Job]}) it's~also returned by the~\hyperref[kotlincoroutinelaunch]{\mbit{launch}} builder, and~actually even by the~\hyperref[kotlincoroutineasync]{\mbit{async}} builder -- the~\mbit{Deferred} interface extends the~\mbit{Job} interface.
\mbox{The \hyperref[kotlincoroutinerunblocking]{\mbit{runBlocking}}} builder doesn't return a~job, unless explicitly returned in~its~callback.
Retrieving the~job from~the~context is convenient inside the~coroutine, retrieving from~the~builder outside.

\example[coroutine job retrieval and usage]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    runBlocking {
        val jobOutside = launch {
            // It's the same object as jobOutside, but the map result is nullable
            val jobInside = coroutineContext[Job]!!

            if (jobInside.isCancelled) {
                (*...THAT\textquotesingle{}S BAD...*)
            }
        }

        if (jobInside.isCompleted) {
            (*...THAT\textquotesingle{}S GOOD...*)
        }
    }
\end{lstlisting}

\example[returning a job from \textit{runBlocking}]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val jobOutside = runBlocking {
        ...
        coroutineContext[Job]!!
    }
\end{lstlisting}

\warning When a~coroutine is created by a~builder, it~always gets a~new~job.
There's no way how to~assign an~existing job to~a~created coroutine.
As~jobs are context elements, and,~therefore, are~instances of the~\mbit{Context} interface, it's~possible to~pass a~job to~a~builder parameter.
However, this~will~make the~passed job only a~parent job of~the~created coroutine, not~directly the~coroutine~job.

\example[passing a job to a builder]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    runBlocking {
        // Using the factory function Job() to create a standalone job
        val standaloneJob = Job()

        val launchJob = launch(standaloneJob) {
            ...
        }

        // standaloneJob and launchJob are different objects
    }
\end{lstlisting}

\warning Parent cancellation\ldots

\note The~\mbit{Job} function creates an~instance of~the~interface \mbit{CompletableJob}.
That's a~job with~available function \mbit{cancel} to~forcibly cancel the~corresponding coroutine.
Default jobs (of~the~type \mbit{Job}) don't provide this~function.

\todo invokeOnCompletion

\example[creation, retrieval and~force cancellation of~a~job]
%! language = TEXT
\begin{lstlisting}[language=Kotlin]
    val simpleJob = Job()
    val scopeWithJob = CoroutineScope(simpleJob)
    ...RUN COROUTINE...

    // If the job is active and something is wrong, cancel the job.
    if (
        simpleJob.isActive
        && SOME_BAD_CONDITION
    ) {
        // Passing the exception isn't necessary, but it's convenient.
        simpleJob.cancel(
            CancellationException("Something went wrong")
        )
    }
\end{lstlisting}

\newsubsection{Dispatchers}
\label{kotlincoroutinedispatcher}
