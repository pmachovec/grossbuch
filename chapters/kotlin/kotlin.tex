\newchapter{Kotlin}

\newsection{Constructors}
\label{kotlinconstructor}
A~standard constructor for~a~Kotlin class is~created by~the~keyword \textitquoted{constructor}.
This~is equivalent to~constructors in~Java.
Overloading of~constructors by~different \hyperref[parameterargument]{parameters} is~possible.

\example[Kotlin class with constructor overloading]
\begin{lstlisting}[language=Kotlin]
    class simpleClass {
        constructor() {
            ...
        }

        constructor(someVariable: SomeClass) {
            ...
        }
    }
\end{lstlisting}

\newsubsection{Primary Constructor}
\index{Primary constructor}
\label{kotlinprimaryconstructor}
Typical constructor usage in~Java is just assigning received \hyperref[parameterargument]{arguments} to~class variables (\textitquoted{this.someVariable = someVariable;}).
In~Kotlin there's a~syntax called \textitquoted{primary constructor} for~simplifying this.
It~works by~specifying variables with types in~brackets directly in~a~class header (see~the~example).
It's~possible to~have both primary and~standard constructors, but~standard must always call the~primary~one.
Also, standard must have different \hyperref[parameterargument]{parameters}, it's~still constructor overloading.
\newpage

\example[Kotlin class with primary and standard constructors]
\begin{lstlisting}[language=Kotlin]
    class simpleClass(someVariable: SomeClass) {
        // Calling primary constructor from the standard one
        constructor() : this(SOME_VALUE) {
            ...
        }

        // Conflict with primary constructor
        // constructor(someVariable: SomeClass) : this(SOME_VALUE) {}

        // Calling primary constructor from the standard one
        constructor(someVariable: SomeClass, otherVariable: OtherClass) : this(SOME_VALUE) {
            ...
        }
    }
\end{lstlisting}

\noindent Primary constructor can~be empty.
That happens when you specify empty brackets in~a~class header.
However, such~constructor lacks any~sense.
\example[empty primary constructor]
\begin{lstlisting}[language=Kotlin]
    class simpleClass() {
        // Conflict with primary constructor
        constructor() : this(SOME_VALUE) {}

        Conflict with primary constructor
        constructor(someVariable: SomeClass) : this(SOME_VALUE) {
            ...
        }
    }
\end{lstlisting}

\newsection{Operators Overloading}
\index{Operators overloading}
\label{kotlinoperatoroverload}

\newsection{Callable References}
\index{Callable reference}
\label{kotlincallablereference}
Double colon\dots

\newsection{Objects}
\index{Object}
\label{kotlinobject}
Kotlin has the~ability to~provide the~\hyperref[singletondp]{singleton design pattern} without any~special implementation or~framework.
Instead of~a~standard class it's possible to~\hyperref[declarationdefinition]{define} an~\textit{object}.
Objects are almost (but~not~completely) same as~classes.
They can~be instantiated and~assigned to~variables, they can~implement interfaces and~extend classes.
When an~object is~called for~the~first time, it's~instantiated.
Each~further call refers to~the~same instance.
It~isn't necessary to~assign an~object instance to~a~variable, it~can~be referred by~the~object name.

\example[object definition and~usage, the~object implements an~interface]
\begin{lstlisting}[language=Kotlin]
    object SimpleObject: SimpleInterface {
        lateinit var simpleValue: String
    }

    // Object instantiated, notice there are no brackets
    val simpleVariable = SimpleObject
    simpleVariable.value = "one"
    SimpleObject.value = "two"
    println(simpleVariable.value) // Will print "two"
    println(SimpleObject.value)   // Will print "two
\end{lstlisting}

\noindent Objects can't~be inherited and~don't allow to~be~declared with the~keyword \textitquoted{open}.
They also can't~have \hyperref[kotlinconstructor]{constructors}, not~even \hyperref[kotlinprimaryconstructor]{primary}.
However, this can~be hacked by~\hyperref[kotlinoperatoroverload]{overloading the~operator} \textitquoted{invoke}.

\example[object looking like having a~constructor]
\begin{lstlisting}[language=Kotlin]
    object ObjectWithConstructor {
        lateinit var value: String

        operator fun invoke(value: String): ObjectWithConstructor {
            this.value = value
            return this
        }
    }

    val objectWithConstructor = ObjectWithConstructor("SOMETHING")
    println(objectWithConstructor.value) // Will print "SOMETHING"
\end{lstlisting}
\newline

\noindent Java equivalent of~a~Kotlin object is~a~final class implementing the~\hyperref[singletondp]{singleton design pattern}.
The~instance variable in~such class is~\hyperref[javapublic]{public}, \hyperref[javastatic]{static} and~\hyperref[javafinal]{final}.
This enables the~described behavior.
\newpage

\example[Java equivalent of~a~Kotlin object]
\begin{lstlisting}[language=Java]
    public final class SimpleObject {
        @>@NotNull
        public static String simpleValue;
        public static final SimpleObject INSTANCE;

        private SimpleObject(){}

        static {
            SimpleObject var0 = new SimpleObject();
            INSTANCE = var0;
        }

        ...COMPLEX GETTER AND SETTER FOR simpleValue...
    }
\end{lstlisting}

\warning Getting a~\hyperref[kotlincallablereference]{callable reference} (double colon) from an~object doesn't create the~singleton instance.
This can~be important when dealing with \hyperref[objectinitblock]{initializer blocks of~objects}.

\newsection{Companion Objects}
\index{Companion object}
\label{companionobject}
It's~an~\hyperref[kotlinobject]{object} \hyperref[declarationdefinition]{defined} inside a~standard class.
It~doesn't have own name, it's~just a~code block labeled as \textitquoted{companion object}.
\hyperref[variablefieldproperty]{Fields} and~functions \hyperref[declarationdefinition]{defined} inside a~companion object can~be~accessed over the~main class, like \hyperref[javastatic][static] members in~Java.
Companion objects basically represent those special instances created by~Java for~\hyperref[javastatic][static] members.

\example[class with companion object]
\begin{lstlisting}[language=Kotlin]
    class ClassWithCompanionObject {
        companion object {
            lateinit var simpleValue: String
        }
    }

    ClassWithCompanionObject.simpleValue = "SOMETHING"
\end{lstlisting}

\note Class members outside a~companion object, and~therefore even instances of~the~class, can't~access members of~the~companion object.
This prevents unwanted overriding of~the~singleton instance \hyperref[variablefieldproperty]{fields}.

\newsection{Initializer Blocks}
\index{Initializer block}
\index{Init block}
\label{kotlininitblock}
These are code blocks labeled by~the~keyword \textitquoted{init}.
They can~appear in~classes even in~\hyperref[kotlinobject]{objects} including \hyperref[companionobject]{companion objects}.
They're executed at~the~initialization of~their holding objects.
They can~access \hyperref[variablefieldproperty]{fields} of~their holding structures (classes or~objects), but~if~these aren't initialized with the~holding structure (which can~happen for~\textit{lateinit} \hyperref[variablefieldproperty]{fields}), it~thows the~exception \textitquoted{UninitializedPropertyAccessException}.

There can~be more initializer blocks in~one class or~object.
In~that case they're executed in~the~top--down order of~their \hyperref[declarationdefinition]{definition}.

\newsubsection{In~a~class}
For~classes initializer blocks are~executed on~each \textbf{outside} constructor call.
If~a~constructor calls another constructor (inside constructor call chain), for~example, an~explicit constructor calls the~\hyperref[kotlinprimaryconstructor]{primary~one}, blocks are~executed only once.

Initializer blocks are~executed before constructors, even when there's a~constructor call chain.
When a~constructor~\textit{B} calls a~constructor~\textit{A}, and~it's~called from outside, first all~initializer blocks are~executed, then~the~constructor~\textit{A} and~then the~constructor~\textit{B}.

Initializer blocks can~access \hyperref[parameterargument]{arguments} of~\hyperref[kotlinprimaryconstructor]{primary constructors}.
To~read an~\hyperref[parameterargument]{argument} of~a~standard constructor, the~only way is to~pass it somehow to~the~\hyperref[kotlinprimaryconstructor]{primary~one}.

\example[class with an~initializer block]
\begin{lstlisting}[language=Kotlin]
    class ClassWithInitBlock(simpleValue: String) {
        init {
            // Accessing argument of the primary constructor
            println(simpleValue)
        }

        // Passing argument to the primary constructor
        constructor(firstValue: String, secondValue: String) : this(firstValue) {
            println(secondValue)
        }
    }

    // Will print "SOMETHING" (the block) followed by "SOMETHING ELSE" (the constructor)
    val classInstance = ClassWithInitBlock("SOMETHING", "SOMETHING ELSE")
\end{lstlisting}

\newsection{In~an~object}
\label{objectinitblock}
As~objects are~initialized only on~the~first call, initializer blocks of~objects are~called only in~that moment.
There are no~constructor traps, because objects can't~have constructors.
If~you~simulate a~constructor by~\hyperref[kotlinoperatoroverload]{overloading the~invocation operator}, the~behavior is the~same as~with an~ordinary function.
I.e.,~if it's a~first call of~the~object, initializer blocks are~called, otherwise~not.

\example[object with an~initializer block]
\begin{lstlisting}[language=Kotlin]
    object ObjectWithInitBlock {
        init {
            println("one")
        }

        fun doSomething() {
            println("SOMETHING")
        }

        init {
            println("two")
        }
    }

    // Will print "one" (first block) followed by "two" (second block) followed by "SOMETHING" twice (two calls of the function)
    ObjectWithInitBlock.doSomething()
    ObjectWithInitBlock.doSomething()
\end{lstlisting}

\warning Remember that getting a~\hyperref[kotlincallablereference]{callable reference} from an~object doesn't instantiate the~object, therefore, initializer blocks aren't triggered in~such situations.

\newsubsection{In~a~companion object}
Initializer blocks of~a~\hyperref[companionobject]{companion object} are similar to~those in~standard \hyperref[kotlinobject]{objects}.
They're~called on~the~first call of~the~class holding~it, no~matter what call it~is.

\newsection{Main Function}
Like you~need the~\textit{main} method in~Java as~a~starting point of~a~program, you~need the~\textit{main} function in~Kotlin.
It~seems simple at~the~first glance\,--\,just \hyperref[declarationdefinition]{define} a~function:
\begin{lstlisting}[frame=no, language=Kotlin]
    fun main(args: Array<String>) {
        ...
    }
\end{lstlisting}

\noindent But~it~doesn't work like this.
\hyperref[jdkjrejvm]{JRE}~won't trigger a~class with such function, it~will~complain that it~\textitquoted{could not find or~load main class}.
Compare the~definition with the~Java definition of~the~\textit{main} method:
\begin{lstlisting}[frame=no, language=Java]
    public static void main(String[] args) {
        ...
    }
\end{lstlisting}

\noindent The~problem is the~\hyperref[javastatic]{\textit{static} access modifier}.
There's no \textit{static} in~Kotlin.
Therefore, it~isn't possible to~\hyperref[declarationdefinition]{define} the~\textit{main} function as~a~standard class function.
There~are two possibilities how to~create a~\textit{main} function in~Kotlin\,--\,in~a~\hyperref[companionobject]{companion object} or~as~a~standalone function (without a~class).

\newsubsection{In~a~companion object}
\index{JvmStatic}
This is more old school Java approach.
You~define a~\textit{main} function in~a~\hyperref[companionobject]{companion object} of~a~class.
You~must additionally annotate the~function with the~annotation \textit{@JvmStatic}.
That's because object functions transformed to~Java methods aren't created as~static by~default, and~the~main method must~be static.
With the~annotation the~keyword \textit{static} is~added to~the~generated method.
The~class can~be then used as~the~main class.

\example[main function in~a~companion object]
\begin{lstlisting}[language=Kotlin]
    class simpleClass {
        companion object {
            @>@JvmStatic
            fun main(args: Array<String>) {
                ...
            }
        }
    }
\end{lstlisting}

\newsubsection{In~a~standalone function}
This is the~real Kotlin approach.
Kotlin enables to~have functions outside classes.
For~a~file containing these standalone functions a~class with \textitquoted{-kt} at~the~end of~the~name is~generated and~each function has~a~corresponding static method.

\example{standalone main function in a~file \textit{Example.kt}}
\begin{lstlisting}[language=Kotlin]
    fun main(args: Array<String>) {
        ...SOME CODE...
    }
\end{lstlisting}

\example{corresponding Java code}
\begin{lstlisting}[language=Java]
    public final class ExampleKt {
        public static final void main(@NotNull String[] args) {
            Intrinsics.checkParameterIsNotNull(args, "args");
            ...SOME CODE...
        }
    }
\end{lstlisting}
