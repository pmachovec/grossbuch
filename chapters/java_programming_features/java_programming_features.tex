\newchapter{Java Programming Features}

\newsection{Abstract classes}
\index{Abstract class}
\label{javaabstractclasses}

\newsection{Interfaces}
\index{Interface}
\label{javainterfaces}

\newsection{Annotations}
\index{Annotations}
\index{Java annotations}
\label{javaannotation}
Annotations are~special labels by~components of~Java code denoted by~the~at~sign (\itq{@}).
They carry additional information\,--\,metadata\,--\,about components they denote.
Although annotations have no direct effect on~the~annotated code operation, they're processed, either during compilation or~during runtime.
The~most typically used annotation is \hyperref[javaoverride]{\mbit{@Override}}.

\newsubsection{Custom Annotations}
\label{javacustomannotations}
Annotations aren't just fixed, developers can~create their own.
Annotation \hyperref[declarationdefinition]{definition} looks like a~simple class \hyperref[declarationdefinition]{definition}.
The~key word stating that an~annotation is~defined is \mbitq{@interface} (with the~at~sign at~the~beginning).
Annotation classes can~contain method \hyperref[declarationdefinition]{declarations} (without a~body), which in~fact define annotation \hyperref[parameterargument]{parameters}.
These method headers are~always public and~cant't~get an~\hyperref[javaaccessmodifiers]{access modifier}.
They can~be~followed by~the~keyword \mbitq{default} followed by~a~default value of~the~corresponding \hyperref[parameterargument]{parameter}.
The~default value type must match the~return type from the~method header.
If~a~parameter method doesn't have assigned default value, then the~parameter is~compulsory when using the~annotation.

Annotation usage and~behavior is~defined by~other, Java built--in annotations, sometimes called \textit{metaannotations}.
There are many of~them, but~only \mbitq{@Retention} and~\mbitq{@Target} are~necessary.

The~\mbit{@Retention} annotation defines if~the~custom annotation is~processed during compilation or~runtime.
It~gets one~of~values of~the~\mbitq{RetentionPolicy} enum.
There are only three possibilities:
\begin{itemize}
    \itembfd{RUNTIME} annotation is~processed during runtime.
    \itembfd{CLASS} annotation is~processed during compilation and~incorporated to~the~created \hyperref[bytecode]{bytecode}.
    \itembfd{SOURCE} annotation is~processed during compilation and~is~not~incorporated to~the~created \hyperref[bytecode]{bytecode}.
             I.e.,~the~annotation is~missing after eventual decompilation.
\end{itemize}

The~\mbit{@Target} annotation defines entities to~which the~custom annotation can~be applied.
It~gets one~or~more (enclosed in curly braces in~that~case) values of~the~\mbitq{ElementType} enum.
There are eleven possible values in~total.
They're quite self--explanatory, like \mbitq{METHOD}, \mbitq{FIELD} or~\mbitq{TYPE}.

\newsubsection{Processing Annotations During Runtime}
This is relatively easy.
The~basic idea is to~get a~reference to~a~class with \hyperref[reflection]{reflection}, explore annotations of~its members or~the~class itself, and~when a~desired annotation is~detected, trigger some action.

\example
\begin{lstlisting}[language=Java, title={Annotation processed during runtime, applicable to fields and methods}]
    @@>@Retention<@@(RetentionPolicy.RUNTIME)
    @@>@Target<@@({ElementType.FIELD, ElementType.METHOD})
    public @interface (*\tmnbf{annot1annot}{ExampleAnnotation}*) {
        String (*\tmnbf{annot1param}{exampleParameter}*)() default "example default value";
    }
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Annotation usage}]
    public class (*\tmnbf{annot1usageclass}{SimpleClass}*) {
        @>@(*\tmnbf{annot1usageannot1}{ExampleAnnotation}[LimeGreen]*)
        private String (*\tmnbf{annot1usagefield}{simpleField}*);

        @@>@(*\tmnbf{annot1usageannot2}{ExampleAnnotation}[LimeGreen]*)<@@((*\tmnbf{annot1usageparam}{exampleParameter}*) = "new value")
        public void simpleMethod() {
            ...
        }
    }
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Runtime annotation processing}]
    Class<?> simpleClass = (*\tmnbf{annot1procclass}{SimpleClass}*).class;
    Field simpleField = simpleClass.getDeclaredField("(*\tmnbf{annot1procfield}{simpleField}[ForestGreen]*)");

    if (simpleField.isAnnotationPresent((*\tmnbf{annot1procannot1}{ExampleAnnotation}*).class)) {
        (*\tmnbf{annot1procannot2}{ExampleAnnotation}*) exampleAnnotation = simpleField.getAnnotation((*\tmnbf{annot1procannot3}{ExampleAnnotation}*).class);
        String exampleParameterValue = exampleAnnotation.(*\tmnbf{annot1procparam}{exampleParameter}*)();
        ...DO SOMETHING WITH THE PARAMETER VALUE...
    }
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{[xshift=3mm] annot1annot.south west}{annot1usageannot1.north}
    \drawarrow{[xshift=3mm] annot1annot.south west}{annot1usageannot2.north}
    \drawarrow{[xshift=3mm] annot1annot.south west}{[xshift=3mm] annot1procannot1.north west}
    \drawarrow{[xshift=3mm] annot1annot.south west}{annot1procannot2.north}
    \drawarrow{[xshift=3mm] annot1annot.south west}{[xshift=3mm] annot1procannot3.north west}
    \drawarrow{[xshift=-3mm] annot1param.south east}{[xshift=6mm] annot1usageparam.north}[red]
    \drawarrow{[xshift=-3mm] annot1param.south east}{[xshift=6mm] annot1procparam.north}[red]
    \drawarrow{[xshift=3mm] annot1usageclass.south}{[xshift=-3mm] annot1procclass.north}[green]
    \drawarrow{[xshift=6mm] annot1usagefield.south}{[xshift=3mm] annot1procfield.north west}[blue]
\end{tikzpicture}

\newsubsection{Processing Annotations During Compilation}
That's much worse.
First, annotation must be already prepared in~the~compile time.
I.e.,~the~source code of~the~annotation class must be already compiled and~packed to~a~jar, which must be added to~classpath.
In~other words, you~must create the~annotation as~a~separate program (subproject is enough), pack it to~a~jar and~put it to~classpath.
Only then you~can~start writing the~code that uses the~annotation.

In~the~annotation program a~processor class must be created.
The~class must~be annotated with (repeatable) annotation \mbitq{@SupportedAnnotationTypes}, which specifies processed annotation class (or~classes), and~with annotation \mbitq{@SupportedSourceVersion}, which specifies minimal Java version under which the~processed annotation is~available during compilation.
The~class must also extend the~class \mbitq{AbstractProcessor} and~implement the~method \mbitq{process}.
The~method can~access annotated elements and~annotation values from its~\hyperref[parameterargument]{parameters}, namely from the~rounding environment, and~perform some action when a~desired annotation is~detected.

It's~desirable to~\hyperref[javaoverride]{override} the~\mbitq{init} method, retrieve the~processing environment messager in~it and~store the~messager to~a~global variable.
Interactions with the~compilation process (breaking compilation, printing warnings, \dots) in~the~\mbit{process} method are~then done through this messager, namely through its method \mbitq{printMessage}.
The~method can~take up~to~four \hyperref[parameterargument]{parameters}, but~only first two are~important:
\begin{itemize}
    \itembfd{Kind} a~member of~the~enum \mbitq{Diagnostic.Kind}.
             Specifies the~action to~perform.
             For~example, the~value \mbitq{ERROR} will~cause the~compilation to~fail.
    \itembfd{Message} character sequence (can~be string) with the~message to~display.
\end{itemize}
\noindent Nevertheless, it's~convenient to~use the~three--parameter version.
The~third parameter is~the~annotated element retrieved from the~\mbit{process} method parameters.
This~way the~element is~included to~printed information.

Additionally, the~jar must~be constructed so~that it~has a~file called exactly \mbitql{javax.;;annotation.;;processing.;;Processor} (without any further extension) inside the~\mbitql{META--INF/;;services} folder.
Inside this file there must~be package path to~the~processor class.
\newpage

\example
\begin{lstlisting}[language=Java, title={Annotation processed during compilation, included in~compiled code, applicable to~fields and~methods}]
    package (*\tmnbf{annot2annotpkg}{annotationpackage}*);

    @@>@Retention<@@(RetentionPolicy.SOURCE)
    @@>@Target<@@({ElementType.FIELD, ElementType.METHOD})
    public @interface (*\tmnbf{annot2annot}{ExampleAnnotation}*) {
        String (*\tmnbf{annot2param}{exampleParameter}*)() default "example default value";
    }
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Annotation processor, working from Java~8, failing when annotated element is encountered}]
    package (*\tmnbf{annot2procpkg}{processorpackage}*);

    @@>@SupportedAnnotationTypes<@@("(*\tmnbf{annot2procannotpkg}{annotationpackage}[ForestGreen]*).(*\tmnbf{annot2procannot1}{ExampleAnnotation}[ForestGreen]*)")
    @@>@SupportedSourceVersion<@@(SourceVersion.RELEASE_8)
    public class (*\tmnbf{annot2proc}{ExampleProcessor}*) extends AbstractProcessor {
        private Messager messager;

        @>@Override
        public synchronized void init(ProcessingEnvironment processingEnv) {
            messager = processingEnv.getMessager();
        }

        @>@Override
        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
            for (Element element: roundEnv.getElementsAnnotatedWith((*\tmnbf{annot2procannot2}{ExampleAnnotation}*).class)) {
                messager.printMessage(Diagnostic.Kind.ERROR, element.getAnnotation((*\tmnbf{annot2procannot3}{ExampleAnnotation}*).class). (*\tmnbf{annot2procparam}{exampleParameter}*)(), element);
            }
        }
    }
\end{lstlisting}
\begin{lstlisting}[title={The file \textit{javax.annotation.processing.Processor}}]
    (*\tmnbf{annot2fileprocpkg}{processorpackage}*).(*\tmnbf{annot2fileproc}{ExampleProcessor}*)
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{annot2annotpkg.south}{[xshift=6mm] annot2procannotpkg.north west}
    \drawarrow{[xshift=-3mm] annot2annot.south east}{annot2procannot1.north}[red]
    \drawarrow{[xshift=-3mm] annot2annot.south east}{annot2procannot2.north}[red]
    \drawarrow{[xshift=-3mm] annot2annot.south east}{annot2procannot3.north}[red]
    \drawarrow{annot2param.south}{[xshift=-3mm] annot2procparam.north}[green]
    \drawarrow{annot2procpkg.south}{annot2fileprocpkg.north}[blue]
    \drawarrow{[xshift=3mm] annot2proc.south}{[xshift=3mm] annot2fileproc.north}[Magenta]
\end{tikzpicture}
\newpage

\newsection{Generic Types}
\index{Generic type}
\label{javagenerics}

\newsection{Threads}
\index{Thread}
\label{javathread}

\newsubsection{Thread safety}
\label{javathreadsafety}

\newsection{String VS StringBuilder VS StringBuffer}
\index{String}
\index{StringBuilder}
\index{StringBuffer}

\newsection{Reflection}
\index{Reflection}
\label{reflection}

\newsection{Imports with Wildcards}
\index{Import}
\index{Wildcard}
Some people say that when you import two or~more classes from one package, or~two or~more methods from one~class, you~should use the~wildcard import (i.e.,~something like \textit{import~package.*}).
It's~even written in~the~book \textit{Clean Code} by~Robert C.~Martin.
However, there are many objections to~this approach.

The~main (and~actually the~only) argument favouring imports with wildcards is that they make the~code shorter, therefore, more readable.
This~is somehow true, but~today's IDEs, even those for~free like Eclipse or~NetBeans, can~collapse import sections automatically.
If~someone is~writing code in~some editor not~capable of~this, then he's either a~beginner not~ready for~a~real IDE and~long imports, or~he's an~idiot.
Also, when a~class has~too~many imports, it's~too~dependent to~other classes, therefore, too~big and~more susceptible to~errors (if~a~dependant class breaks, my~class breaks,~too), and~therefore,~bad.
Furthermore, when~a~wildcard import is~used, the~class generally has~more imports than with explicit imports, and~the~previous problem with too~many imports is~even more serious.

Then there are only arguments against wildcard imports.
And~one of~them~is, funny enough, the~readability.
With wildcard imports it's~harder to~tell where an~imported feature comes from.
Consider the~following code:
\begin{lstlisting}[language=Java]
    import firstPackage.*;
    import secondPackage.*;
    import thirdPackage.*;

    public class ExampleClass {
        private MysteryClass mysteryInstance = new MysteryClass();
    }
\end{lstlisting}

\noindent It~isn't clear what package the~\textit{MysteryClass} class comes from.
Consider it's~somehow broken and~compilation fails, and~\textit{Ctrl}\,+\,click also~doesn't work (let's~say the~package library is~completely missing).
And~now consider this code:
\begin{lstlisting}[language=Java]
    import firstPackage.SomethingUseless;
    import secondPackage.SomethingEvenMoreUseless;
    import thirdPackage.MysteryClass;

    public class ExampleClass {
        private MysteryClass mysteryInstance = new MysteryClass();
    }
\end{lstlisting}

\noindent Here it's~clear that the~\textit{MysteryClass} class comes from the~third package.
So,~when observing problems, it's~clear where to~look.

Now~consider that the~previous code with wildcard imports works, i.e.,~there~is a~class called \textit{MysteryClass} in~the~third package.
And~now the~author of~the~second package, which lives on~the~other side of~the~world and~you don't know each~other, gets the~amazing idea to~create a~class called \textit{MysteryClass} in~the~second package.
Suddenly, there's an~ambiguity in~your code, compilation stops working and~you're screwed.
But~with explicit imports the~code still works without a~need of~change.

\note The~most favoured linter Ktlint for~Kotlin language, which slowly starts to~push away Java, forbids wildcard imports in~the~default configuration.

\newsection{Compound Assignment}
\index{Compound assignment}
Compound assignment operators are those shortened assignments with arithmetic operators like \mbox{\textquotesingle\textit{+=}\textquotesingle} or~\mbox{\textquotesingle\textit{-=}\textquotesingle}.
You~must~be extra careful when dealing with the~subtraction compound operator (\mbox{\textquotesingle\textit{-=}\textquotesingle}).
It~first computes the~right side and~then subtracts it from~the~left side, and~that can~cause unintuitive results.
For~example consider the~following code:
\begin{lstlisting}[language=Java, frame=no]
    int x = 5;
    x = x - 1 + 2 - 3; @>// 3
\end{lstlisting}

\noindent The~variable~$x$ is~evaluated to~$3$, because $5-1+2-3=3$.
And~now consider an~"equivalent" code with the~compound assignment subtraction:
\begin{lstlisting}[language=Java, frame=no]
    int x = 5;
    x -= 1 + 2 - 3; @>// 5
\end{lstlisting}

\noindent The~variable~$x$ is~evaluated to~$5$, because $1+2-3=0$ (right side) and~$5-0=5$ (left side).
To~avoid falling to~this trap always treat the~right side to~be calculated first.

\newsection{Serialization}
\index{Serialization}
\index{Serializable}
\label{serialization}

\newsection{Servlets}
\index{Servlet}
\label{servlet}
A~Java program executed by~an~\hyperref[applicationserver]{application server} (most usually \hyperref[tomcat]{Tomcat}) based on~a~request (theoretically doesn't have to~be~\hyperref[http]{HTTP}, but~nowadays nothing else is~used) from a~client is~called \mbit{servlet}.
\hyperref[webserviceapplication]{Web services} implemented in~Java are~servlets.
The~implementation of~servlets is~said to~use the servlet~\hyperref[api]{API}

For~each servlet there is~a~class implementing the~interface \mbitq{javax.servlet.Servlet}.
This class is~an~entry point of~the~servlet program, sometimes the~class alone is (incorrectly) denoted as~\mbit{servlet}.
It~contains methods (enforced by its interface) that are~triggered when the~servlet is initiated (\itq{void init(ServletConfig config)}), when a~request comes to~it (\itq{void service(ServletRequest request, ServletResponse response)} and~when it's~terminated (\itq{void destroy()}).
Note that even the~\textit{service} method, from which some response is~expected, is~void.
The~response is~written to~a~writer instance of~the~\textit{response} object.

\enlargethispage{10mm}
\example
\begin{lstlisting}[language=Java]
    import java.io.PrintWriter;
    import javax.servlet.Servlet;
    import javax.servlet.ServletRequest;
    import javax.servlet.ServletResponse;

    public class ExampleServlet implements Servlet {
        ...
        protected void service(ServletRequest request, ServletResponse response) {
            ...
            PrintWriter out = response.getWriter();
            out.print("...EXAMPLE...");
            out.flush();
        }
        ...
    }
\end{lstlisting}

\newsubsection{Servlet Invocation}
Each servlet class must have~assigned some~URL\@.
When the~\hyperref[applicationserver]{application server} URL, correct port and~the~servlet URL are~invoked (for~example, in~a~web browser address bar), the~\textit{service} method of~the~class is~executed.
From there other classes and~methods can~be invoked.
The~content written to~the~writer of~the~response object is~sent back to~the~invoking client (a~web~browser displays it instead of~a~web~page).
One~servlet can~be configured as~the~default one, this is triggered when no~servlet URL part is~written to the~address~bar.

There already are some classes implementing the~\textit{Servlet} interface.
New~servlet classes are~implemented as~extending these classes.
With this approach a~developer can override only methods he needs, the~original \textit{Servlet} interface doesn't have to be implemented whole again.

\newsubsection{\textit{Service} method VS \textit{doGet} and \textit{doPost}}
\label{servicedopostdoget}
 Today's servlet classes usually extend the~\textit{HttpServlet} class and~the~logic of~servlets is~implemented by~overriding methods \textit{doGet} and~\textit{doPost} from that class, not~the~original \textit{service}.
That's because today's servlets are~triggered by web requests from web browsers, which use the~\hyperref[http]{HTTP protocol}.
This~\hyperref[protocolstandard]{protocol} enables (beside others) two~most common methods of~a~HTTP request\,--\,\textit{GET} and~\textit{POST}.
When an~\hyperref[applicationserver]{application server} gets a~\hyperref[http]{HTTP} request, it~actually triggers the~\textit{service} method, but~it~adds a~parameter with the~method type to~the~\textit{request} object.
Based on~this parameter the~implementation of~the\textit{service} method from the~\textit{HttpServlet} class delegates other parameters to~\textit{doGet} or~\textit{doPost} method, which are~expected to~be overridden by~the~developer (their body is empty in~the~\textit{HttpServlet} class).

When a~servlet is~invoked by~typing its URL to~a~web browser address bar, the~\hyperref[http]{HTTP} request has the~method~\textit{GET}, i.e., the~\textit{doGet} method is~triggered.
Eventual parameters available in~the~\textit{request} object can~be written as~a~part of~the~complete URL written to~the~address bar.
The~\textit{POST} method in~the~request, and~therefore even the~\textit{doPost} method in~the~servlet class, can~be triggered only by submitting a~HTML form configured to~use the~\textit{POST} method or~by~running a~\hyperref[javascript]{JavaScript} function on~the~client side.

\newsection{Java Server Pages (JSP)}
\index{JSP}
\index{Java server pages}
\label{jsp}
When a~\hyperref[http]{HTTP} request to~a~servlet is~sent from a~web browser, the~response is~displayed in~that~browser.
When some meaningful \hyperref[internetweb]{web} page should be displayed, its~whole source code must be written to~the~response, i.e.,~something like this:

\begin{lstlisting}[language=Java]
    import java.io.IOException;
    import java.io.PrintWriter;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;

    public class ExampleServlet extends HttpServlet {
        ...
        @>@Override
        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
            ...
            PrintWriter out = response.getWriter();
            out.print("<html>");
            out.print("<head>");
            ...
            out.flush();
        }
        ...
    }
\end{lstlisting}

\noindent That sucks.
As~a~solution there are~JSP~pages.
A~JSP page is~basically a~HTML page with some advanced features for~interactions with request parameters, executing Java code and~dynamic context generation.
When a~\hyperref[http]{HTTP} request is~sent to~a~JSP page, its~content (dynamically adjusted based on~the~request) is~sent as~the~response (and~displayed in~the~initiating browser).

\warning JSP pages are~very dangerous for~code readability.
They enable mixing five syntaxes\,--\,HTML, CSS, Java, JavaScript and~\hyperref[el]{EL}\,--\,into one~file.
And~although this is considered and~known to~be a~VERY bad practice, you can~be sure that a~stressed and~tired developer, pressed by incompetent managers to~finish his job till yesterday (i.e.,~a~standard developer), will create a~real anarchy with this tool in~his~hands.

\newsubsection{Java Standard Tag Library (JSTL)}
\index{Java standard tag library}
\index{JSTL}
\label{jstl}

\newsubsection{Attribute VS Parameter}
\index{Attribute}
\index{Parameter}
\label{jspattributeparameter}

\newsubsection{Namespaces}
\index{Namespace}

\newsubsection{Expression Language (EL)}
\index{Expression language}
\index{EL}
\label{el}
