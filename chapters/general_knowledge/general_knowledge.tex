\newchapter{General Knowledge}

\newsection{Operating System (OS)}
\index{Operating system}
\index{OS}
\label{os}
It's~a~basic software of~a~computer that manages the~computer's hardware, other software, their mutual communication, \hyperref[systemmemory]{memory} allocation and~interaction with a~user.
Many operating systems also handle parallel \hyperref[applicationprocessprogramservicethread]{process} execution\,--\,\hyperref[multitasking]{multitasking}.
Some sort of~OS should be installed to~a~computer as~a~part of~the~computer construction in~order to~make the~computer usable for~an~ordinary user.
Controlling computer without an~OS (including the~initial OS installation) requires passing precise machine instructions directly to~the~computer \hyperref[processorcpucore]{processor}, which only computer manufacturers and~true specialists are~capable~of.

\newsubsection{Kernel}
\index{Kernel}
\index{Kernel space}
\index{User space}
\label{kernel}
It's~the~core part of~an~OS, which manages the~connection of~\hyperref[applicationprocessprogramservicethread]{processes} with the~computer hardware.
I.e.,~it~controls \hyperref[processorcpucore]{processor} management (assigning processor time to~processes), \hyperref[systemmemory]{memory} management (assigning memory space to~processes), computer devices and~communication with peripherals (keyboard, mouse, monitor, speakers,~\dots).
Kernels have allocated a~special part of~the~\hyperref[systemmemory]{system memory} called \textit{kernel space}.
The~remaining part of~the~\hyperref[systemmemory]{memory} is~called \textit{user space}.

\newsubsection{Monolithic Kernel}
\index{Monolithic kernel}
\label{monolithickernel}
It's~an~old--fashioned type of~kernel where all kernel parts, as~described above, use the~kernel space.
\hyperref[unixlinux]{Unix and~Linux} systems typically have monolithic kernels.

\newsubsection{Microkernel}
\index{Microkernel}
\label{microkernel}
It's~an~opposite to~the~monolithic kernel.
It~runs only the~absolute minimum for~the~computer control using the~kernel space.
The~minimum consists basically of~\hyperref[processorcpucore]{processor} management and~\hyperref[systemmemory]{memory} management.
All~other kernel functions are~handled as~standard processes (called \hyperref[server]{servers} when dealing with microkernels) using the~user space.
Microkernels are~more stable than monolithic kernels and~their functionality can~be extended by~adding new~servers without a~need of~recompilation, but~on~the~other hand they're slower.

\newsubsection{Hybrid kernel}
\index{Hybrid kernel}
\label{hybridkernel}
It's~a~combination of~\hyperref[monolithickernel]{monolithic kernel} and~\hyperref[microkernel]{microkernel} combining (dis)advantages of~both.
The~kernel functionalities are~separated to~servers like in~a~\hyperref[microkernel]{microkernel}, but~they~run in~the~kernel space.
This preserves the~stability of~the~kernel with significantly less impact on~performance.
The~disadvantage of~this~approach is that adding new servers is more complicated (and~impossible during runtime) than with \hyperref[microkernel]{microkernels}.
Today's top commercial \hyperref[os]{operating systems} like Windows or~macOS have hybrid kernels (or~at~least Microsoft and~Apple say~so).

\newsection{Platform}
\index{Platform}
\label{platform}
This term has~multiple meanings.
It~can~denote:
\begin{enumerate}[label=\arabic*)]
    \item A~set of~tools for~writing and~running \hyperref[applicationprocessprogramservicethread]{programs}, like Java (the~language and~\hyperref[jdkjrejvm]{JDK}) or~\hyperref[dotnet]{.NET}.
    \item A~combination of~\hyperref[os]{OS} and~hardware.
\end{enumerate}

\newsection{Character Set VS Encoding}
\index{Character set}
\index{Encoding}
\index{ASCII}
\index{Unicode}
\label{charactersetencoding}
\begin{itemize}
    \itembf{Character set} is a~list of~characters, with which a~computer is~capable to~work.
            Each~computer has a~character set.
            Even software can~have a~character set (such~software then runs only on~computers supporting that character set).
            \mbit{ASCII}~and~\mbit{Unicode} are~typical examples of~character~sets.
    \itembfd{Encoding} computers work only with numbers.
             Each character of a~character set is~represented as~a~number.
             And~encoding specifies which number (code) corresponds to~which character.
             To~make things confusing, the~ASCII character set encoding is~also called~\mbit{ASCII}.
             Unicode character set has~more encodings like \hyperref[utf]{\mbit{UTF--8} or~\mbit{UTF--16}}.
\end{itemize}

\newsection{UTF--8 VS UTF--16}
\index{UTF--8}
\index{UTF--16}
\label{utf}
\begin{itemize}
    \itembf{UTF--8} is a~superset of~ASCII encoding.
            I.e.,~codes of~basic characters included in~the~ASCII character set are~the~same in~UTF--8 and~ASCII encodings.
            This is helpful when converting characters from~one encoding to~the~other.
            The~number of~consumed bytes per~character encoded in~\mbox{UTF--8} varies from~1 to~4~bytes depending on~the~need.
    \itembf{UTF--16} uses different codes and,~despite its name, is~incompatible with~\mbox{UTF--8}.
            It~consumes 2 or~4 bytes per~character.
            Codes of~Asian languages characters are~lower in~\mbox{UTF--16} than in~\mbox{UTF--8}, and~generally where \mbox{UTF--8} uses 3~bytes, there \mbox{UTF--16} uses only 2~bytes.
            Therefore, \mbox{UTF--16} is more effective when dealing with Asian languages.
            Also, \hyperref[java]{Java} and~\hyperref[dotnet]{.NET} work better with~it (only Chuck Norris knows~why).
\end{itemize}

\newsection{Package Manager}
\index{Package manager}
\index{Package management system}
\label{packagemanager}
A~package manager, or~package management system, is~a~software for~simplification and~automation of~computer programs installation, configuration, upgrading and~deletion.
Programs are distributed in~packages, which contain the~program software itself packaged in~an~archive file (zip,~tar,\dots) and~metadata like program name, description or~dependencies to~other programs.
Package managers are~usually connected with package repositories available over the~\hyperref[internetweb]{internet}.

Package managers are typical for~\hyperref[linux]{Linux} \hyperref[os]{operating systems}, for~example Debian or~Ubuntu use the~popular~\hyperref[linuxapt]{APT}.
Oracle Linux has the~\href{http://yum.baseurl.org/}{Yum}.
But~there~are also some package managers available for~Windows, like \href{https://www.nuget.org/}{NuGet} or~\href{https://chocolatey.org/}{Chocolatey}.
There~is also the~\hyperref[windowspackagemanagement]{PackageManagement} (formerly OneGet), which connects more Windows package managers to~one application.
Some people say that the~PackageManagement is a~package manager manager.

Not~only \hyperref[os]{operating systems} have package managers.
Some programming languages or~platforms also have their package managers.
For~example, Python has \href{https://pypi.org/}{PyPI} and~Node.js has~\hyperref[npm]{NPM}.
Gradle or~Maven with a~connection to~Maven repositories can~also be considered as~package managers (for~Java).

\newsection{Architecture VS Design}
\index{Architecture}
\index{Design}
\label{architecturedesign}
Both these terms denote some description of~a~system before its implementation.
They differ in~the~level of~abstraction, i.e.,~in~how~concrete the~description~is.
\begin{itemize}
    \itembf{Architecture} is a~high abstraction level.
            It~describes main components of~a~system, their properties and~relations among them.
            Examples of~such components are~used programming language, individual functional parts to~implement, \hyperref[databases]{database} software or~\hyperref[server]{servers}.
          One~architecture can~be used for~multiple designs.
          Solutions for~issues commonly occurring in~software architectures are~described by~\hyperref[architecturalpatterns]{architectural patterns}.
    \itembf{Design} is a~low abstraction level.
            It~describes implementation details more in~detail, like classes, functions, their relations etc.
            Software design can~be described by~an~UML diagram.
            There can~be more designs for~one~system, each~describing different part of~the~system.
            Solutions for~issues commonly occurring in~software designs are~described by~\hyperref[designpatterns]{design patterns}.
\end{itemize}

\newsection{.NET}
\index{.NET}
\index{NET}
\index{Dot NET}
\label{dotnet}
Pronounced [d\textopeno{}tn\textepsilon{}t], it's~a~multi--purpose framework and~runtime environment, i.e.,~a~\hyperref[platform]{platform}.
Developed by~Microsoft, it's~available in~Windows by~default, but~nowadays it~can~be downloaded and~used even in~Linux environments.
Languages \mbox{for~.NET} are~compiled to~CIL (\textit{Common Intermediate Language}, equivalent of~\hyperref[bytecode]{Java bytecode}) and~executed by~CLR (\textit{Common Language Runtime}, equivalent of~\hyperref[jdkjrejvm]{JRE}).
Examples of~such languages are~C\# or~Visual Basic.
\hyperref[powershell]{PowerShell} heavily uses .NET programs in~the~form of~\hyperref[cmdlet]{cmdLets}, but~itself it~has an~\hyperref[compiledinterpretedlanguages]{interpreter}, which doesn't produce~CIL\@.

\newsection{Variable VS Field VS Property}
\index{Variable}
\index{Field}
\index{Property}
\label{variablefieldproperty}
\begin{itemize}
    \itembf{Variable} is a~general term denoting data with named identifier.
    \itembf{Field} is a~variable defined in~a~class outside any~method.
            Fields store parts of~class instance states.
            Class constants are~fields, variables defined inside \mbox{methods/functions} and~cycles are~not.
    \itembf{Property} is a~field that is~exposed to~outside of~the~class, typically by~getters and~setters.
\end{itemize}

\newsection{Parameter VS Argument}
\index{Argument}
\index{Attribute}
\index{Parameter}
\label{parameterargument}
\begin{itemize}
    \itembf{Parameter} is a~\hyperref[variablefieldproperty]{variable} in~a~method \hyperref[declarationdefinition]{declaration}.
    \itembf{Argument} is a~concrete value of~a~parameter.
\end{itemize}
For~example consider a~method \mbitq{doSomething(String someVariable)}.
The~\mbit{someVariable} is~a~parameter.
When you call \mbitq{doSomething("someValue")}, then \mbit{someValue} is an~argument.

\warning Don't get confused by the~term \textit{attribute}.
That's either a~different name for~a~\hyperref[variablefieldproperty]{field} of~an~object or~for~a~\hyperref[relationaldatabase]{relational database} table column.

\newsection{Data Types}
\index{Data type}
\label{datatypes}
Each~\hyperref[variablefieldproperty]{variable} in~fact denotes a~sequence of~zeros and~ones in~the~\hyperref[systemmemory]{memory}, i.e.,~values of~memory bits.
A~data type, usually written exactly before the~variable in~the~code, is~an~information for~\hyperref[compiledinterpretedlanguages]{a~compiler or~an~interpreter} how to~interpret that sequence, i.e.,~what value that sequence denotes.

Each~programming language can~theoretically interpret the~same value differently, but~basics like numbers corresponding to~characters are~usually the~same.
For~example consider the~value 1100001.
When treated as~the~\textit{integer} type (\textit{int}~in some languages), it~represents the~number~97.
When treated as~the~\textit{character} type (\textit{char}~in some languages), it~represents the~minuscule letter~\itq{a}.

\newsection{Declaration VS Definition}
\index{Declaration}
\index{Definition}
\label{declarationdefinition}
\begin{itemize}
    \itembf{Declaration of~a~variable} means specifying the~variable name, \hyperref[datatypes]{type} and~eventually \hyperref[javaaccessmodifiers]{access level}.
            It~doesn't include assigning a~value to~the~variable.
            Example: \mbitq{private int a;}.
    \itembf{Declaration of~a~method (or~a~function)} is the~method header.
            It~consists of~the~method name, return value \hyperref[datatypes]{type}, number, names and~\hyperref[datatypes]{types} of~arguments of~the~method and~eventually its \hyperref[javaaccessmodifiers]{access level}.
            Example: \mbitq{public void doSomething(int a);}.
    \itembf{Definition of~a~variable} means assigning a~value to~the~variable.
            It~can~immediately follow the~variable definition (\itq{private int a = 1;}) or~appear later as~a~separate command (\itq{private int a; \dots a = 1;}).
    \itembf{Definition of~a~method (or~a~function)} is the~method header with the~method body.
            Example: \mbitq{public void doSomething(int a) \{ \dots \}}".
\end{itemize}

\noindent Generally a~declaration informs \hyperref[compiledinterpretedlanguages]{a~compiler or~an~interpreter} about some structure.
Definition allocates a~memory for~the~structure.
There can~be a~declaration without a~definition, but~not~reversed.
One~variable or~method (or~function) can~be declared multiple times, but~defined maximally once.
When you assign a~new value to~already defined variable, you~rewrite the~already allocated memory.
That isn't a~new definition.

\section*{\fontsize{17}{17} \selectfont Program VS Application VS Process VS Service VS Thread}
\addcontentsline{toc}{section}{Application VS Process VS Program VS Service VS Thread}
\index{Program}
\index{Application}
\index{Process}
\index{Service}
\index{Thread}
\index{Computer program}
\label{applicationprocessprogramservicethread}
\begin{itemize}
    \itembf{Program} is the~most general term of these.
            It's included in all others.
            A~computer program is a~set of~instructions that can~be executed on a~computer.
    \itembf{Application} is a~computer program with which, when it's executed, users actively interact.
    \itembf{Process} is a~particular executed and~running instance of a~program.
    \itembf{Service} is a~process that runs continuously in the~background without active interaction with a~user.
            I.e., it's the opposite of application.
    \itembf{Thread} is a~set of consecutive steps performed one by~one in a~process.
            A~process can~be separated to~more threads which can run in~parallel (if~the~program implementation supports~it).
\end{itemize}

\newsubsection{Web Service VS Web Application}
\index{Web service}
\index{Web application}
\label{webserviceapplication}
\begin{itemize}
    \itembf{Web~service} is any~program executed or~continuously running on a~remote computer, with which programs on~other computers communicate over the~\hyperref[internetweb]{Web}, i.e.,~using the~\hyperref[http]{HTTP protocol}.
            A~program called \hyperref[clientserverarchitecture]{\mbit{client}}, running on a~user's computer, sends a~request to~another~program called \hyperref[clientserverarchitecture]{\mbit{server}} running on~the~remote computer (the~same computer as the~target remote program), the~server delegates the~request to~the~remote program, the~remote program processes the~request and~sends a~response to~the~server, which then delegates it back to~the~client.
            \warningnonl The~term \textit{web service} is~ambiguous.
            Sometimes it denotes solely the~remote program, sometimes it includes even the~server.
            Also, opposite to~a~standard \hyperref[applicationprocessprogramservicethread]{service} the~remote program doesn't have to run continuously.
            Only the~server does.
    \itembf{Web~application} is basically a~web~service with a~\hyperref[shellcligui]{GUI} in~a~web browser on~the~client side.
            In~a~web application a~user actively interacts with a~web page, based on~this interaction requests are~sent to~a~web service, responses are~sent back and~visualised in~the~browser.
\end{itemize}
\newpage

\newsection{Server}
\index{Server}
\label{server}
Exactly speaking a~server is a~continuously running software getting requests from another software and~sending responses back, i.e.,~providing a~\hyperref[applicationprocessprogramservicethread]{service} for~that other software.
Servers are~often running on~specialized computers, which themselves are~called servers and~what many people think that servers~are.
But~server software can~be generally running on~any~computer.
Examples of~servers are~\hyperref[webserver]{web servers}, \hyperref[applicationserver]{application servers}, \hyperref[proxy]{proxy servers} etc.

\newsection{Engine}
\index{Engine}
\label{engine}
Engine is any~software performing a~specific task.
Usually software performing nontrivial tasks is~denoted as~engine.
For~example, \hyperref[jdkjrejvm]{JVM} is~an~engine executing (compiled) Java code.
But~even a~simple \textit{Hello World} program is an~engine in~fact.

\newsection{Distributed System}
\index{Distributed system}
\label{distributedsystem}
It's a~system whose components are~located on~different networked computers, which communicate and~coordinate their actions by~passing messages to~one~another.
All~components communicate to~achieve a~common goal.
Distributed systems have three main characteristics:
\begin{itemize}
    \item Components work \hyperref[concurrency]{concurrently}.
    \item There is no global clock\,--\,no~time synchronization among components.
    \item Components fail independently\,--\,if~one~component fails, other components are~not~affected.
\end{itemize}
\noindent Examples are~computer networks (including the~\hyperref[internetweb]{Internet}) or~telephone networks.

\newsubsection{Distributed Version Control System}
\index{Distributed version control system}
\label{distributedversioncontrolsystem}
It's~a~version control system where each user owns a~copy (mirror) of~the~whole code base including the~whole history.
The~typical example of~such system is~\hyperref[git]{Git}.

\newsection{Protocol VS Standard}
\index{Protocol}
\index{Standard}
\index{Communication protocol}
\label{protocolstandard}
Both are~systems of~rules that developers should follow to~provide mutual compatibility and~interoperability of~their programs in~some ways depending on the~protocol or~standard.
The~difference is that protocols describe communication over a~network.
That's why the~term \itq{communication protocol} is~used sometimes.
There are no other protocols than communication.

Standards have much broader range, they can~describe any software or~even hardware.
For~example, USB is a~standard that computers and external devices follow to~be able to~cooperate.

\warning It's~clear that not~all standards are protocols, but~also not~all protocols are standards.
They mostly are, like~\hyperref[http]{HTTP} or~\hyperref[ssh]{SSH}, but~anyone can~create own protocol not~bound by~any~rules.
Bigger companies do that for~their internal communication.
Also, even when \hyperref[networkprotocols]{general protocols} are~actually standards, nobody denotes them as~standards.
They're always protocols.

\newsection{Multitasking}
\index{Multitasking}
\label{multitasking}

\newsection{Concurrency}
\index{Concurrency}
\label{concurrency}

\newsection{Loose Coupling VS Tight Coupling}
\index{Loose coupling}
\index{Tight coupling}
\label{loosetightcoupling}

\newsection{Base64}
\index{Base64}
\label{base64}
It's an~encoding used for~representation of~any array of~bytes as an~ASCII string.
The~name refers to the~size of~the~set of~resulting characters, which is~64.
It~encodes always three bytes to~four characters.
If~the~length of~the~input byte array is~not~divisible by~three, one or~two special bytes are~added to~its~end.
This results in~one or~two equals signs at~the~end of~the~resulting string.

\newsection{Shell VS CLI VS GUI}
\index{Shell}
\index{CLI}
\index{GUI}
\label{shellcligui}
\begin{itemize}
    \itembf{Shell} is any software for~controlling \hyperref[os]{operating system}.
    \itembf{CLI} (Command Line Interface) is~a~user interface for~controlling specific software in~a~form of~single text line to~which commands are~typed.
            Shells typically (but~not~always) exist in~a~CLI form.
            Windows command line or~a~\hyperref[linux]{Linux} terminal are~shells.
            There can also be CLIs that are~not shells, for~example, Python console.
    \itembf{GUI} (Graphical User Interface) is~a~user interface for~controlling specific software in~a~graphic form.
            Even shells can, and~often~do, exist in~a~GUI form.
            For~example, Windows screen (or~GUI screen of~any~other~\hyperref[os]{OS}) is~a~shell.
\end{itemize}

\newsection{Application Programming Interface (API)}
\index{Application programming interface}
\index{API}
\label{api}
It's~a~part of~a~software serving for~communication with other software.
The~word \textit{application} is~inaccurate, even \hyperref[applicationprocessprogramservicethread]{services} can~have~API (it's~actually typical part of~a~service).
It's~a~very broad term.
For~example, when a~browser is~requesting \hyperref[internetweb]{web} pages from a~\hyperref[webserver]{web~server}, it~communicates with the~server~API\@.
When a~process is~supposed to~run under an~\hyperref[os]{OS}, it~communicates with the~API of~that~OS\@.
Methods defined in~a~class form an~API (of~instances) of~that~class.
And~so~forth.

\newsection{Authentication VS Authorization}
\index{Authentication}
\index{Authorization}
\label{authenticationauthorization}
\begin{itemize}
    \itembf{Authentication} is a~process of~validating user's identity.
            For~example, a~user, before he~can~start using an~\hyperref[applicationprocessprogramservicethread]{application}, must somehow prove who~he~is.
            And~he~does this typically by providing user name and~password.
            The~application contains an~authentication mechanism, which verifies the~user's identity (or~not).
            In~multi--factor authentication the~user must provide more proofs, for~example, a~code arriving to~his mobile as~SMS.
            Fingerprint or~eye scans, known mostly from American movies (but~existing even in~real world), are~also forms of~authentication.
    \itembf{Authorization} is a~process of~validating user's rights to~access various resources.
            User's identity must~be~known for~authorization, therefore, it~must follow an~authentication (which provides the~identity).
            For~example, a~company's internal information system contains an~authorization mechanism, which authorizes every employee to~access the~system, but~only very few employees are~authorized to~access information about wages in~that system.
\end{itemize}
