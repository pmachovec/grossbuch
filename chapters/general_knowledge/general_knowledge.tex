\newchapter{General Knowledge}

\newsection{Operating System (OS)}
\index{Operating system}
\index{OS}
\label{os}
It's~a~basic software of~a~computer that manages the~computer's hardware, other software, their mutual communication, \hyperref[systemmemory]{memory} allocation and~interaction with a~user. Many operating systems also handle parallel \hyperref[applicationprocessprogramservicethread]{process} execution\,--\,\hyperref[multitasking]{multitasking}. Some sort of~OS should be installed to~a~computer as~a~part of~the~computer construction in~order to~make the~computer usable for~an~ordinary user. Controlling computer without an~OS (including the~initial OS installation) requires passing precise machine instructions directly to~the~computer \hyperref[processorcpucore]{processor}, which only computer manufacturers and~true specialists are~capable~of.

\newsubsection{Kernel}
\index{Kernel}
\index{Kernel space}
\index{User space}
\label{kernel}
It's~the~core part of~an~OS, which manages the~connection of~\hyperref[applicationprocessprogramservicethread](processes) with the~computer hardware. I.e.,~it~controls \hyperref[processorcpucore]{processor} management (assigning processor time to~processes), \hyperref[systemmemory]{memory} management (assigning memory space to~processes), computer devices and~communication with peripherals (keyboard, mouse, monitor, speakers,~\dots). Kernels have allocated a~special part of~the~\hyperref[systemmemory]{system memory} called \textbf{kernel space}. The~remaining part of~the~\hyperref[systemmemory]{memory} is~called \textbf{user space}.

\newsubsection{Monolithic Kernel}
\index{Monolithic kernel}
\label{monolithickernel}
It's~an~old--fashioned type of~kernel where all kernel parts, as~described above, use the~kernel space. \hyperref[unixlinux]{Unix and~Linux} systems typically have monolithic kernels.

\newsubsection{Microkernel}
\index{Microkernel}
\label{microkernel}
It's~an~opposite to~the~monolithic kernel. It~runs only the~absolute minimum for~the~computer control using the~kernel space. The~minimum consists basically of~\hyperref[processorcpucore]{processor} management and~\hyperref[systemmemory]{memory} management. All~other kernel functions are~handled as~standard processes (called \hyperref[server]{servers} when dealing with microkernels) using the~user space. Microkernels are~more stable than monolithic kernels and~their functionality can~be extended by~adding new~servers without a~need of~recompilation, but~on~the~other hand they're slower.

\newsubsection{Hybrid kernel}
\index{Hybrid kernel}
\label{hybridkernel}
It's~a~combination of~\hyperref[monolithickernel]{monolithic kernel} and~\hyperref[microkernel]{microkernel} combining (dis)advantages of~both. The~kernel functionalities are~separated to~servers like in~a~\hyperref[microkernel]{microkernel}, but~they~run in~the~kernel space. This preserves the~stability of~the~kernel with significantly less impact on~performance. The~disadvantage of~this~approach is that adding new servers is more complicated (and~impossible during runtime) than with \hyperref[microkernel]{microkernels}. Today's top commercial \hyperref[os]{operating systems} like Windows or~macOS have hybrid kernels (or~at~least Microsoft and~Apple say~so).

\newsection{POSIX}
\index{POSIX}
\label{posix}
The~abbreviation stands for~\textit{Portable Operating System Interface} (yes,~\textit{X} is~missing). It's~a~set of~standards specifying \hyperref[api]{APIs}, command line \hyperref[shellcligui]{shells} and~utility interfaces. These standards serve for~maintaining compatibility between \hyperref[os]{operating systems}. Any~software working on~one~system following standards will~work even on~a~different system following standards. It's~typical for~\hyperref[unixlinux]{Unix and~Linux} systems.

\newsection{Unix VS Linux}
\index{Unix}
\index{Linux}
\label{unixlinux}
\begin{itemize}
    \item \textbf{Unix},~often written in~capital letters (UNIX), was~originally a~\hyperref[shellcligui]{CLI}--controlled~\hyperref[os]{OS} developed in 1969 by~\href{https://en.wikipedia.org/wiki/Bell_Labs}{Bell~Labs} for~their internal use. In~late 1970s Bell~Labs owner \href{https://en.wikipedia.org/wiki/AT\%26T}{AT\&T} started to~sell Unix \hyperref[licencing]{licences} to~outside parties, which created their own enhanced mutations of~the~original~system. Nowadays there is so~called Unix family, which denotes all~\hyperref[os]{operating systems} derived this way from the~original Unix. The~most known Unix of~today is~probably macOS (although having \hyperref[hybridkernel]{hybrid kernel}). \warningnonl Unix systems are~commercial and~their owners don't release source codes (they also had~to~pay for~the~\hyperref[licencing]{licence}).
    \item \textbf{Linux} was~originally only an~\hyperref[kernel]{OS~kernel} developed in~1991 by~\href{https://en.wikipedia.org/wiki/Linus_Torvalds}{Linus Torvalds}. It~was~heavily inspired by~Unix (they both follow \hyperref[posix]{POSIX} standards), but~opposite to~Unix the~Linux source code was~publicly released under the~\hyperref[gpl]{GNU GPL} licence. \hyperref[os]{Operating systems} said to~be~Linux use variations of~that original Linux kernel. Although claimed to~be~free, there are~even commercial Linuxes containing some nontrivial enhancements or~specializations, for~example SUSE Linux Enterprise for~\hyperref[server]{server} computers.
\end{itemize}
\newpage

\newsection{Architecture VS Design}
\index{Architecture}
\index{Design}
\label{architecturedesign}
Both these terms denote some description of~a~system before its implementation. They differ in~the~level of~abstraction, i.e.,~in~how~concrete the~description~is.
\begin{itemize}
    \item \textbf{Architecture} is a~high abstraction level. It~describes main components of~a~system, their properties and~relations among them. Examples of~such components are~used programming language, individual functional parts to~implement, \hyperref[databases]{database} software or~\hyperref[server]{servers}. One~architecture can~be~used for~multiple designs. Solutions for~issues commonly occurring in~software architectures are~described by~\hyperref[architecturalpatterns]{architectural patterns}.
    \item \textbf{Design} is a~low abstraction level. It~describes implementation details more in~detail, like classes, functions, their relations etc. Software design can~be described by~an~UML diagram. There can~be~more designs for~one~system, each~describing different part of~the~system. Solutions for~issues commonly occurring in~software designs are~described by~\hyperref[designpatterns]{design patterns}.
\end{itemize}

\newsection{Object--Oriented Programming}
\index{Object--oriented programming}
\label{objectorientedprogramming}
It's~a~programming paradigm in~which data are~encapsulated into objects together with tools for~manipulating these data. An~object holds data in~\hyperref[variablefieldproperty]{fields} (also called attributes) and~provides methods (also called functions) for~manipulating with these data (typically from other objects). Java and~most other languages using the~object paradigm like C\# or C++ are~not~pure object languages, because they contain \hyperref[javadatatypes]{primitive} \hyperref[datatypes]{data types} like \textit{integer} or~\textit{boolean}. In~pure object languages all~data (each variable) must be object. An~example of a~pure object language is Smalltalk (and~there is~probably no~other).

\warning Object--oriented programming is~not contradictory to~\hyperref[imperativeprogramming]{imperative programming} (or~even \hyperref[declarativeprogramming]{declarative programming}, see further).

\newsection{Basic Concepts of Object--Oriented Programming}

\newsubsection{Encapsulation}
\index{Encapsulation}

\newsubsection{Inheritance}
\index{Inheritance}

\newsubsection{Polymorphism}
\index{Polymorphism}

\newsubsection{Abstraction}
\index{Abstraction}

\newsection{Object VS Data Structure}

\newsection{Object--Oriented VS Procedural Programming}
\index{Procedural programming}

\newsection{Imperative Programming}
\index{Imperative programming}
\label{imperativeprogramming}
It's a~programming paradigm in which a~program behavior is changed by~specified statements. It's opposite of~\hyperref[declarativeprogramming]{declarative programming}.

\warning It is \textbf{not} contradictory to \hyperref[objectorientedprogramming]{object--oriented programming}, imperative languages can be object--oriented. Actually, today's most used object--oriented languages (Java, C\#, C++) are imperative.

\newsection{Declarative Programming}
\index{Declarative programming}
\label{declarativeprogramming}
It's a~programming paradigm in which programs describe their desired results without explicitly listing commands or steps that must be performed. It's opposite~of~\hyperref[imperativeprogramming]{imperative programming}. Typical examples of~declarative languages are~SQL or~Prolog. Oracle's PL/SQL is a~kind of~hybrid language using imperative statements combined with declarative SQL. Even declarative languages can be \hyperref[objectorientedprogramming]{object--oriented} (there~is an~object extension for~Prolog).

\newsection{Compiled VS Interpreted Languages}
\index{Compiled language}
\index{Interpreted language}
\label{compiledinterpretedlanguages}

\newsection{Variable VS Field VS Property}
\index{Variable}
\index{Field}
\index{Property}
\label{variablefieldproperty}
\begin{itemize}
    \item \textbf{Variable} is a~general term denoting data with named identifier.
    \item \textbf{Field} is a~variable defined in~a~class outside any~method. Fields store parts of~class instance states. Class constants are~fields, variables defined inside \mbox{methods/functions} and~cycles are~not.
    \item \textbf{Property} is a~field that is~exposed to~outside of~the~class, typically by~getters and~setters.
\end{itemize}

\newsection{Parameter VS Argument}
\index{Argument}
\index{Attribute}
\index{Parameter}
\label{parameterargument}
\begin{itemize}
    \item \textbf{Parameter} is a~\hyperref[variablefieldproperty]{variable} in~a~method \hyperref[declarationdefinition]{declaration},
    \item \textbf{Argument} is a~concrete value of~a~parameter.
\end{itemize}
For~example consider a~method "\mboxtextit{doSomething(String someVariable)}". The~\mboxtextit{someVariable} is~a~parameter. When you call "\mboxtextit{doSomething("someValue")}", then \mboxtextit{someValue} is an~argument.

\warning Don't get confused by the~term \textit{attribute}. That's either a~different name for~a~\hyperref[variablefieldproperty]{field} of~an~object or~for~a~\hyperref[relationaldatabase]{relational database} table column.

\newsection{Data Types}
\index{Data type}
\label{datatypes}
Each~\hyperref[variablefieldproperty]{variable} in~fact denotes a~sequence of~zeros and~ones in~the~\hyperref[systemmemory]{memory}, i.e.,~values of~memory bits. A~data type, usually written exactly before the~variable in~the~code, is~an~information for~\hyperref[compiledinterpretedlanguages]{a~compiler or~an~interpreter} how to~interpret that sequence, i.e., what value that sequence denotes.

Each~programming language can~theoretically interpret the~same value differently, but~basics like numbers corresponding to~characters are~usually the~same. For~example consider the~value 1100001. When treated as~the~\textit{integer} type (\textit{int}~in some languages), it~represents the~number~97. When treated as~the~\textit{character} type (\textit{char}~in some languages), it~represents the~minuscule letter~\textit{a}.

\newsection{Declaration VS Definition}
\index{Declaration}
\index{Definition}
\label{declarationdefinition}
\begin{itemize}
    \item \textbf{Declaration of~a~variable} means specifying the~variable name, \hyperref[datatypes]{type} and~eventually \hyperref[accessmodifiers]{access level}. It~doesn't include assigning a~value to~the~variable. Example: "\textit{\mbox{private int a;}}".
    \item \textbf{Declaration of~a~method (or~a~function)} is the~method header. It~consists~of the~method name, return value \hyperref[datatypes]{type}, number, names and~\hyperref[datatypes]{types} of~arguments of~the~method and~eventually its \hyperref[accessmodifiers]{access level}. Example: "\textit{\mbox{public void doSomething(int a);}}".
    \item \textbf{Definition of~a~variable} means assigning a~value to~the~variable. It~can~immediately follow the~variable definition ("\textit{private int a = 1;}") or~appear later as~a~separate command ("\textit{private int a; ... a = 1;}").
    \item \textbf{Definition of~a~method (or~a~function)} is the~method header with the~method body. Example: "\textit{\mbox{public void doSomething(int a) \{ ... \}}}".
\end{itemize}
\noindent Generally a~declaration informs \hyperref[compiledinterpretedlanguages]{a~compiler or~an~interpreter} about some structure. Definition allocates a~memory for~the~structure. There can be a~declaration without a~definition, but~not~reversed. One~variable or~method (or~function) can be declared multiple times, but~defined maximally once. When you assign a~new value to~already defined variable, you~rewrite the~already allocated memory. That isn't a~new definition.

\section*{\fontsize{17}{17} \selectfont Program VS Application VS Process VS Service VS Thread}
\addcontentsline{toc}{section}{Application VS Process VS Program VS Service VS Thread}
\index{Program}
\index{Application}
\index{Process}
\index{Service}
\index{Thread}
\index{Computer program}
\label{applicationprocessprogramservicethread}
\begin{itemize}
    \item \textbf{Program} is the~most general term of these. It's included in all others. A~computer program is a~set of~instructions that can be executed on a~computer.
    \item \textbf{Application} is a~computer program with which, when it's executed, users actively interact.
    \item \textbf{Process} is a~particular executed and~running instance of a~program.
    \item \textbf{Service} is a~process that runs continuously in the~background without active interaction with a~user. I.e., it's the opposite of application.
    \item \textbf{Thread} is a~set of consecutive steps performed one by~one in a~process. A~process can be separated to~more threads which can run in~parallel (if~the~program implementation supports~it).
\end{itemize}

\newsubsection{Web Service}
\index{Web service}
\label{webservice}
It's any~program executed or~continuously running on a~remote computer, with which programs on~other computers communicate over the~\hyperref[internetweb]{Web}, i.e.,~using the~\hyperref[http]{HTTP} protocol. A~program called \hyperref[clientserverarchitecture]{client}, running on a~user's computer, sends a~request to~another~program called \hyperref[clientserverarchitecture]{server} running on~the~remote computer (the~same computer as the~target remote program), the~server delegates the~request to~the~remote program, the~remote program processes the~request and~sends a~response to~the~server, which then delegates it back to~the~client.

\warning The~term \textit{web service} is~ambiguous. Sometimes it denotes solely the~remote program, sometimes it includes even the~server. Also, opposite to~a~standard \hyperref[applicationprocessprogramservicethread]{service} the~remote program doesn't have to run continuously. Only the~server does.

\newsection{Server}
\index{Server}
\label{server}
Exactly speaking a~server is a~continuously running software getting requests from another software and~sending responses back, i.e.,~providing a~\hyperref[applicationprocessprogramservicethread]{service} for~that other software. Servers are~often running on~specialized computers, which themselves are~called servers and~what many people think that servers~are. But~server software can~be generally running on~any~computer.
Examples of~servers are~\hyperref[webserver]{web servers}, \hyperref[applicationserver]{application servers}, \hyperref[proxy]{proxy servers} etc.

\newsection{Distributed System}
\index{Distributed system}
\label{distributedsystem}
It's a~system whose components are~located on~different networked computers, which communicate and~coordinate their actions by~passing messages to~one~another. All~components communicate to~achieve a~common goal. Distributed systems have three main characteristics:
\begin{itemize}
    \item Components work \hyperref[concurrency]{concurrently}.
    \item There is no global clock\,--\,no~time synchronization among components.
    \item Components fail independently\,--\,if~one~component fails, other components are~not~affected.
\end{itemize}
\noindent Examples are~computer networks (including the~\hyperref[internetweb]{Internet}) or~telephone networks.

\newsubsection{Distributed Version Control System}
\index{Distributed version control system}
\label{distributedversioncontrolsystem}
It's~a~version control system where each user owns a~copy (mirror) of~the~whole code base including the~whole history. The~typical example of~such system is~\hyperref[git]{Git}.

\newsection{Multitasking}
\index{Multitasking}
\label{multitasking}

\newsection{Concurrency}
\index{Concurrency}
\label{concurrency}

\newsection{Loose Coupling VS Tight Coupling}
\index{Loose coupling}
\index{Tight coupling}
\label{loosetightcoupling}

\newsection{Base64}
\index{Base64}
\label{base64}
It's an~encoding used for~representation of~any array of~bytes as an~ASCII string. The~name refers to the~size of~the~set of~resulting characters, which is~64. It~encodes always three bytes to~four characters. If~the~length of~the~input byte array is~not~divisible by~three, one or~two special bytes are~added to~its~end. This results in~one or~two equals signs at~the~end of~the~resulting string.

\newsection{Shell VS CLI VS GUI}
\index{Shell}
\index{CLI}
\label{shellcligui}
\begin{itemize}
    \item \textbf{Shell} is any software for~controlling \hyperref[os]{operating system}.
    \item \textbf{CLI} (Command Line Interface) is~a~user interface for~controlling specific software in~a~form of~single text line to~which commands are~typed. Shells typically (but~not~always) exist in~a~CLI form. Windows command line or~a~\hyperref[unixlinux]{Linux} terminal are~shells. There can also be CLIs that are~not shells, for~example Python console.
    \item \textbf{GUI} (Graphical User Interface) is~a~user interface for~controlling specific software in~a~graphic form. Even shells can, and~often~do, exist in~a~GUI form. For~example, Windows screen (or~GUI screen~of any~other~\hyperref[os]{OS}) is~a~shell.
\end{itemize}

\newsection{Application Programming Interface (API)}
\index{Application programming interface}
\index{API}
\label{api}
It's~a~part of~a~software serving for~communication with other software. The~word \textit{application} is~inaccurate, even \hyperref[applicationprocessprogramservicethread]{services} can~have~API (it's~actually typical part of~a~service). It's~a~very broad term. For~example, when a~browser is~requesting \hyperref[internetweb]{web} pages from a~\hyperref[webserver]{web~server}, it~communicates with the~server~API. When a~process is~supposed to~run under an~\hyperref[os]{OS}, it~communicates with the~API of~that~OS. Methods defined in~a~class form an~API (of~instances) of~that~class. And~so~forth.
