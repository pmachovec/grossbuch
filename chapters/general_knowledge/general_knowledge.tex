\newchapter{General Knowledge}

\newsection{Operating System (OS)}
\index{Operating system}
\index{OS}
\label{os}
It's~a~basic software of~a~computer that manages the~computer's hardware, other software, their mutual communication, \hyperref[systemmemory]{memory} allocation and~interaction with a~user. Many operating systems also handle parallel \hyperref[applicationprocessprogramservicethread]{process} execution\,--\,\hyperref[multitasking]{multitasking}. Some sort of~OS should be installed to~a~computer as~a~part of~the~computer construction in~order to~make the~computer usable for~an~ordinary user. Controlling computer without an~OS (including the~initial OS installation) requires passing precise machine instructions directly to~the~computer \hyperref[processorcpucore]{processor}, which only computer manufacturers and~true specialists are~capable~of.

\newsubsection{Kernel}
\index{Kernel}
\index{Kernel space}
\index{User space}
\label{kernel}
It's~the~core part of~an~OS, which manages the~connection of~\hyperref[applicationprocessprogramservicethread]{processes} with the~computer hardware. I.e.,~it~controls \hyperref[processorcpucore]{processor} management (assigning processor time to~processes), \hyperref[systemmemory]{memory} management (assigning memory space to~processes), computer devices and~communication with peripherals (keyboard, mouse, monitor, speakers,~\dots). Kernels have allocated a~special part of~the~\hyperref[systemmemory]{system memory} called \textit{kernel space}. The~remaining part of~the~\hyperref[systemmemory]{memory} is~called \textit{user space}.

\newsubsection{Monolithic Kernel}
\index{Monolithic kernel}
\label{monolithickernel}
It's~an~old--fashioned type of~kernel where all kernel parts, as~described above, use the~kernel space. \hyperref[unixlinux]{Unix and~Linux} systems typically have monolithic kernels.

\newsubsection{Microkernel}
\index{Microkernel}
\label{microkernel}
It's~an~opposite to~the~monolithic kernel. It~runs only the~absolute minimum for~the~computer control using the~kernel space. The~minimum consists basically of~\hyperref[processorcpucore]{processor} management and~\hyperref[systemmemory]{memory} management. All~other kernel functions are~handled as~standard processes (called \hyperref[server]{servers} when dealing with microkernels) using the~user space. Microkernels are~more stable than monolithic kernels and~their functionality can~be extended by~adding new~servers without a~need of~recompilation, but~on~the~other hand they're slower.

\newsubsection{Hybrid kernel}
\index{Hybrid kernel}
\label{hybridkernel}
It's~a~combination of~\hyperref[monolithickernel]{monolithic kernel} and~\hyperref[microkernel]{microkernel} combining (dis)advantages of~both. The~kernel functionalities are~separated to~servers like in~a~\hyperref[microkernel]{microkernel}, but~they~run in~the~kernel space. This preserves the~stability of~the~kernel with significantly less impact on~performance. The~disadvantage of~this~approach is that adding new servers is more complicated (and~impossible during runtime) than with \hyperref[microkernel]{microkernels}. Today's top commercial \hyperref[os]{operating systems} like Windows or~macOS have hybrid kernels (or~at~least Microsoft and~Apple say~so).

\newsection{POSIX}
\index{POSIX}
\label{posix}
The~abbreviation stands for~\textit{Portable Operating System Interface} (yes,~\textit{X} is~missing). It's~a~set of~standards specifying \hyperref[api]{APIs}, command line \hyperref[shellcligui]{shells} and~utility interfaces. These standards serve for~maintaining compatibility between \hyperref[os]{operating systems}. Any~software working on~one~system following standards will~work even on~a~different system following standards. It's~typical for~\hyperref[unixlinux]{Unix and~Linux} systems.

\newsection{Unix VS Linux}
\index{Unix}
\index{Linux}
\label{unixlinux}
\begin{itemize}
    \item \textbf{Unix},~often written in~capital letters (UNIX), was~originally a~\hyperref[shellcligui]{CLI}--controlled~\hyperref[os]{OS} developed in 1969 by~\href{https://en.wikipedia.org/wiki/Bell_Labs}{Bell~Labs} for~their internal use. In~late 1970s Bell~Labs owner \href{https://en.wikipedia.org/wiki/AT\%26T}{AT\&T} started to~sell Unix \hyperref[licencing]{licences} to~outside parties, which created their own enhanced mutations of~the~original~system. Nowadays there is so~called Unix family, which denotes all~\hyperref[os]{operating systems} derived this way from the~original Unix. The~most known Unix of~today is~probably macOS (although having \hyperref[hybridkernel]{hybrid kernel}). \warningnonl Unix systems are~commercial and~their owners don't release source codes (they also had~to~pay for~the~\hyperref[licencing]{licence}).
    \item \textbf{Linux} was~originally only an~\hyperref[kernel]{OS~kernel} developed in~1991 by~\href{https://en.wikipedia.org/wiki/Linus_Torvalds}{Linus Torvalds}. It~was~heavily inspired by~Unix (they both follow \hyperref[posix]{POSIX} standards), but~opposite to~Unix the~Linux source code was~publicly released under the~\hyperref[gpl]{GNU GPL} licence. \hyperref[os]{Operating systems} said to~be Linux use variations of~that original Linux kernel. Although claimed to~be free, there are~even commercial Linuxes containing some nontrivial enhancements or~specializations, for~example SUSE Linux Enterprise for~\hyperref[server]{server} computers.
\end{itemize}

\newsection{Architecture VS Design}
\index{Architecture}
\index{Design}
\label{architecturedesign}
Both these terms denote some description of~a~system before its implementation. They differ in~the~level of~abstraction, i.e.,~in~how~concrete the~description~is.
\begin{itemize}
    \item \textbf{Architecture} is a~high abstraction level. It~describes main components of~a~system, their properties and~relations among them. Examples of~such components are~used programming language, individual functional parts to~implement, \hyperref[databases]{database} software or~\hyperref[server]{servers}. One~architecture can~be used for~multiple designs. Solutions for~issues commonly occurring in~software architectures are~described by~\hyperref[architecturalpatterns]{architectural patterns}.
    \item \textbf{Design} is a~low abstraction level. It~describes implementation details more in~detail, like classes, functions, their relations etc. Software design can~be described by~an~UML diagram. There can~be more designs for~one~system, each~describing different part of~the~system. Solutions for~issues commonly occurring in~software designs are~described by~\hyperref[designpatterns]{design patterns}.
\end{itemize}

\newsection{Object--Oriented Programming (OOP)}
\index{Object--oriented programming}
\index{OOP}
\label{objectorientedprogramming}
It's~a~programming paradigm in~which data are~\hyperref[encapsulation]{encapsulated} into objects together with tools for~manipulating these data. An~object holds data in~\hyperref[variablefieldproperty]{fields} (also called attributes) and~provides methods (also called functions) for~manipulating with these data (typically from other objects). Java and~most other languages using the~object paradigm like C\# or C++ are~not~pure object languages, because they contain \hyperref[javadatatypes]{primitive} \hyperref[datatypes]{data types} like \textit{integer} or~\textit{boolean}. In~pure object languages all~data (each variable) must be object. An~example of a~pure object language is Smalltalk (and~there is~probably no~other).

\warning Object--oriented programming is~not contradictory to~\hyperref[imperativeprogramming]{imperative programming} (or~even \hyperref[declarativeprogramming]{declarative programming}, see further).

\newsection{Basic Concepts of OOP}

\newsubsection{Encapsulation}
\index{Encapsulation}
\label{encapsulation}
Encapsulation is the~essence of~OOP. It~means having data (\hyperref[variablefieldproperty]{fields}) and~tools for~manipulating these data (methods, functions) in~a~same object (class). The~access to~data and~tools is~restricted, typically by \hyperref[javaaccessmodifiers]{access modifiers}. The~data can~also be objects, i.e.,~objects can~be encapsulated in~other objects. Purposes~are:
\begin{itemize}
    \item \textbf{Maintainability}\,--\,data and~tools for~manipulating them are~at~one place.
    \item \textbf{Security}\,--\,when the~access is~restricted, users can't read or~change data they aren't supposed to read or~change.
    \item \textbf{Changeability}\,--\,when needed, functionality of~encapsulated tools can~be changed without affecting users of~the~object.
\end{itemize}

\warning Having all \hyperref[variablefieldproperty]{fields} in~an~object private and~providing getters and~setters for~them is not an~encapsulation. This~is just a~convention that most of~OOP languages follow, but~for~example Python, although an~OOP language, accesses fields directly by the~dot notation.

\newsubsection{Inheritance}
\index{Inheritance}
\label{inheritance}
It's~a~mechanism for~avoiding writing a~code for~a~functionality common for~more objects, i.e.,~for~avoiding code duplicity. The~common code is~written only once in~one ancestor object (parent) and~descendant objects (children), which should contain the~code functionality, just inherit the~ancestor. Purposes~are:
\begin{itemize}
    \item \textbf{Simplicity}\,--\,no~need to~write common code more times.
    \item \textbf{Changeability}\,--\,when common code needs a~change, there's only one place to~change.
    \item \textbf{Maintainability}\,--\,same as~changeability.
\end{itemize}

\warning When an~object implements an~\hyperref[javainterface]{interface}, it~isn't the~inheritance, that's the~\hyperref[abstraction]{abstraction}.

\newsubsection{Polymorphism}
\index{Polymorphism}
\index{Virtual method}
It~means that one~method or~function of~an~object can~get \hyperref[parameterargument]{arguments} of~various different \hyperref[datatypes]{data types} in~same \hyperref[parameterargument]{parameter} positions. For~example, basic numberic operations (addition, subtraction,~\dots) work with all available number types. Purposes are:
\begin{itemize}
    \item \textbf{Simplicity}\,--\,no~need to~have a~different method name for~each possible \hyperref[parameterargument]{argument} type combinations.
    \item \textbf{Maintainability}\,--\,same as~simplicity.
\end{itemize}

\noindent There are three types of~the~polymorphism:
\begin{itemize}
    \item \textbf{Ad hoc}\,--\,simple overloading based on~argument types. In~one~object there are more method implementations with the~same number of~parameters, but~in~each these parameters have different types. The~correct implementation is~decided by~types of provided arguments, usually during the~code compilation.
    \item \textbf{Parametrical}\,--\,method parameters have so~called \hyperref[javagenerics]{generic types}, which substitute concrete \hyperref[datatypes]{types}. Correct concrete types are~decided by~used values in~runtime.
    \item \textbf{Subtype}\,--\,connected with the~\hyperref[inheritance]{inheritance} and~\hyperref[virtualmethod]{virtual methods}. There can~be an~ancestor and~a~descendant and you can assign an~instance of~the~descendant to~the~variable of~the~\hyperref[datatype]{type} of~the~ancestor (\textit{Ancestor variable = new Descendant();}). When the~descendant \hyperref[javaoverride]{overrides} a~method \hyperref[declarationdefinition]{defined} in~the~ancestor and~the~method is declared as~\textit{virtual}, calling the~method on~the~variable (which has the~ancestor type) actually triggers the~implementation from the~descendant.
\end{itemize}

\warning In~Java or~C\# all methods are~virtual by~default and~the~subtype polymorphism is~happening automatically.

\newsubsection{Abstraction}
\index{Abstraction}
\index{Level of abstraction}
\label{abstraction}
It~means hiding implementation details of~objects and~providing only tools to~use objects (methods, functions). When you use some already existing library or~\hyperref[api]{API}, you~don't know and~don't care how it works inside. You~only have some object, call a~method and~get a~result. That's the~abstraction. Purposes~are:
\begin{itemize}
    \item \textbf{Simplicity}\,--\,users of~objects are~not~overwhelmed by internal implementation of~those objects, which can~be very complex. They can~simply incorporate objects to~their own implementations regardless objects complexity.
    \item \textbf{Changeability}\,--\,when needed, functionality of~provided tools can~be changed without affecting users of~the~object.
\end{itemize}

\warning The~abstraction is~broken by the~\hyperref[inheritance]{inheritance concept}\,--\,to~correctly implement a~descendant object you should know the~implementation of~the~ancestor. For~this reason it's~recommended to~avoid inheritance as~much as~possible, unless preventing the~code duplicity.

\warning Don't confuse it with the~\hyperref[encapsulation]{encapsulation concept}. They're tightly coupled and~encapsulation doesn't make any use without the~abstraction. You~can quite often encounter a~definition of~one labeled as~a~definition of~the~other. But~they're different. Abstraction handles object manipulation tools, encapsulation handles (beside others) restriction of~access to~these tools. A~developer cares about the~abstraction during software \hyperref[architecturedesign]{design}, and~about the~encapsulation during implementation. The~abstraction (hiding implementation) is~achieved by method headers, \hyperref[javaabstractclasses]{abstract classes} and~\hyperref[javainterfaces]{interfaces} and~the~encapsulation (restricting access) is~achieved by \hyperref[javaaccessmodifiers]{access modifiers}.

Nevertheless, be~aware that deciding how~to~encapsulate \hyperref[javadatatypes]{primitive} variables and~"smaller" objects into "bigger" objects is a~part of~the~\hyperref[architecturedesign]{design}, i.e.,~it~belongs under the~abstraction concept. With varying depth of~\hyperref[variablefieldproperty]{fields} in~the~encapsulation tree we~talk about different levels of~abstraction.

\example[abstraction without encapsulation]
\begin{lstlisting}[language=Java]
    float PI = 3.1415926535897932384626433832795028841971693993751058;
    ...
    doSomethingWithFloat(PI);
\end{lstlisting}

\noindent The~complicated value is~not encapsulated in~an~object, but~it's~hidden behind a~variable. Something like this can actually happen in~real programming.

\example[encapsulation without abstraction]
\begin{lstlisting}[language=Java]
    public class UselessClass {
        private int uselessVariable = 0;
    }
\end{lstlisting}

\noindent The~value is~encapsulated in~the~class, but~is~not~used inside any~method of~the~class. Something like this doesn't happen in~real programming.

\newsection{Object VS Data Structure}

\newsection{Object--Oriented VS Procedural Programming}
\index{Procedural programming}

\newsection{Imperative Programming}
\index{Imperative programming}
\index{Control flow}
\index{Flow of control}
\label{imperativeprogramming}
It's a~programming paradigm in which a~program behavior is changed by~specified statements. The~order of~executing statements is~called \textit{control flow}, or~also \textit{flow of~control}. It's~opposite of \hyperref[declarativeprogramming]{declarative programming}.

\warning It is \textbf{not}~contradictory to~\hyperref[objectorientedprogramming]{object--oriented programming}, imperative languages can~be object--oriented. Actually, today's most used object--oriented languages (Java, C\#, C++) are~imperative.

\newsection{Declarative Programming}
\index{Declarative programming}
\label{declarativeprogramming}
It's a~programming paradigm in which programs describe their desired results without explicitly listing commands or steps that must be performed. It's~opposite of~\hyperref[imperativeprogramming]{imperative programming}. Typical examples of~declarative languages are~SQL or~Prolog. Oracle's PL/SQL is a~kind of~hybrid language using imperative statements combined with declarative SQL. Even declarative languages can~be \hyperref[objectorientedprogramming]{object--oriented} (there~is an~object extension for~Prolog).

\newsection{Compiled VS Interpreted Languages}
\index{Compiled language}
\index{Interpreted language}
\label{compiledinterpretedlanguages}

\newsection{Scripting Languages}
\index{Scripting language}
\index{Shebang}
\label{scriptinglanguages}
Shebang...

\newsection{Variable VS Field VS Property}
\index{Variable}
\index{Field}
\index{Property}
\label{variablefieldproperty}
\begin{itemize}
    \item \textbf{Variable} is a~general term denoting data with named identifier.
    \item \textbf{Field} is a~variable defined in~a~class outside any~method. Fields store parts of~class instance states. Class constants are~fields, variables defined inside \mbox{methods/functions} and~cycles are~not.
    \item \textbf{Property} is a~field that is~exposed to~outside of~the~class, typically by~getters and~setters.
\end{itemize}

\newsection{Parameter VS Argument}
\index{Argument}
\index{Attribute}
\index{Parameter}
\label{parameterargument}
\begin{itemize}
    \item \textbf{Parameter} is a~\hyperref[variablefieldproperty]{variable} in~a~method \hyperref[declarationdefinition]{declaration},
    \item \textbf{Argument} is a~concrete value of~a~parameter.
\end{itemize}
For~example consider a~method "\mboxtextit{doSomething(String someVariable)}". The~\mboxtextit{someVariable} is~a~parameter. When you call "\mboxtextit{doSomething("someValue")}", then \mboxtextit{someValue} is an~argument.

\warning Don't get confused by the~term \textit{attribute}. That's either a~different name for~a~\hyperref[variablefieldproperty]{field} of~an~object or~for~a~\hyperref[relationaldatabase]{relational database} table column.

\newsection{Data Types}
\index{Data type}
\label{datatypes}
Each~\hyperref[variablefieldproperty]{variable} in~fact denotes a~sequence of~zeros and~ones in~the~\hyperref[systemmemory]{memory}, i.e.,~values of~memory bits. A~data type, usually written exactly before the~variable in~the~code, is~an~information for~\hyperref[compiledinterpretedlanguages]{a~compiler or~an~interpreter} how to~interpret that sequence, i.e., what value that sequence denotes.

Each~programming language can~theoretically interpret the~same value differently, but~basics like numbers corresponding to~characters are~usually the~same. For~example consider the~value 1100001. When treated as~the~\textit{integer} type (\textit{int}~in some languages), it~represents the~number~97. When treated as~the~\textit{character} type (\textit{char}~in some languages), it~represents the~minuscule letter~\textit{a}.

\newsection{Declaration VS Definition}
\index{Declaration}
\index{Definition}
\label{declarationdefinition}
\begin{itemize}
    \item \textbf{Declaration of~a~variable} means specifying the~variable name, \hyperref[datatypes]{type} and~eventually \hyperref[accessmodifiers]{access level}. It~doesn't include assigning a~value to~the~variable. Example: "\textit{\mbox{private int a;}}".
    \item \textbf{Declaration of~a~method (or~a~function)} is the~method header. It~consists~of the~method name, return value \hyperref[datatypes]{type}, number, names and~\hyperref[datatypes]{types} of~arguments of~the~method and~eventually its \hyperref[accessmodifiers]{access level}. Example: "\textit{\mbox{public void doSomething(int a);}}".
    \item \textbf{Definition of~a~variable} means assigning a~value to~the~variable. It~can~immediately follow the~variable definition ("\textit{private int a = 1;}") or~appear later as~a~separate command ("\textit{private int a; ... a = 1;}").
    \item \textbf{Definition of~a~method (or~a~function)} is the~method header with the~method body. Example: "\textit{\mbox{public void doSomething(int a) \{ ... \}}}".
\end{itemize}
\noindent Generally a~declaration informs \hyperref[compiledinterpretedlanguages]{a~compiler or~an~interpreter} about some structure. Definition allocates a~memory for~the~structure. There can~be a~declaration without a~definition, but~not~reversed. One~variable or~method (or~function) can~be declared multiple times, but~defined maximally once. When you assign a~new value to~already defined variable, you~rewrite the~already allocated memory. That isn't a~new definition.

\section*{\fontsize{17}{17} \selectfont Program VS Application VS Process VS Service VS Thread}
\addcontentsline{toc}{section}{Application VS Process VS Program VS Service VS Thread}
\index{Program}
\index{Application}
\index{Process}
\index{Service}
\index{Thread}
\index{Computer program}
\label{applicationprocessprogramservicethread}
\begin{itemize}
    \item \textbf{Program} is the~most general term of these. It's included in all others. A~computer program is a~set of~instructions that can~be executed on a~computer.
    \item \textbf{Application} is a~computer program with which, when it's executed, users actively interact.
    \item \textbf{Process} is a~particular executed and~running instance of a~program.
    \item \textbf{Service} is a~process that runs continuously in the~background without active interaction with a~user. I.e., it's the opposite of application.
    \item \textbf{Thread} is a~set of consecutive steps performed one by~one in a~process. A~process can~be separated to~more threads which can run in~parallel (if~the~program implementation supports~it).
\end{itemize}

\newsubsection{Web Service VS Web Application}
\index{Web service}
\index{Web application}
\label{webserviceapplication}
\begin{itemize}
    \item \textbf{Web~service} is any~program executed or~continuously running on a~remote computer, with which programs on~other computers communicate over the~\hyperref[internetweb]{Web}, i.e.,~using the~\hyperref[http]{HTTP} protocol. A~program called \hyperref[clientserverarchitecture]{client}, running on a~user's computer, sends a~request to~another~program called \hyperref[clientserverarchitecture]{server} running on~the~remote computer (the~same computer as the~target remote program), the~server delegates the~request to~the~remote program, the~remote program processes the~request and~sends a~response to~the~server, which then delegates it back to~the~client. \warningnonl The~term \textit{web service} is~ambiguous. Sometimes it denotes solely the~remote program, sometimes it includes even the~server. Also, opposite to~a~standard \hyperref[applicationprocessprogramservicethread]{service} the~remote program doesn't have to run continuously. Only the~server does.
    \item \textbf{Web~application} is basically a~web~service with a~\hyperref[shellcligui]{GUI} in~a~web browser on~the~client side. In~a~web application a~user actively interacts with a~web page, based on~this interaction requests are~sent to~a~web service, responses are~sent back and~visualised in~the~browser.
\end{itemize}

\newsection{Server}
\index{Server}
\label{server}
Exactly speaking a~server is a~continuously running software getting requests from another software and~sending responses back, i.e.,~providing a~\hyperref[applicationprocessprogramservicethread]{service} for~that other software. Servers are~often running on~specialized computers, which themselves are~called servers and~what many people think that servers~are. But~server software can~be generally running on~any~computer.
Examples of~servers are~\hyperref[webserver]{web servers}, \hyperref[applicationserver]{application servers}, \hyperref[proxy]{proxy servers} etc.

\newsection{Engine}
\index{Engine}
\label{engine}
Engine is any~software performing a~specific task. Usually software performing nontrivial tasks is~denoted as~engine. For~example, \hyperref[jdkjrejvm]{JVM} is~an~engine executing (compiled) Java code. But~even a~simple Hello World program is an~engine in~fact.

\newsection{Distributed System}
\index{Distributed system}
\label{distributedsystem}
It's a~system whose components are~located on~different networked computers, which communicate and~coordinate their actions by~passing messages to~one~another. All~components communicate to~achieve a~common goal. Distributed systems have three main characteristics:
\begin{itemize}
    \item Components work \hyperref[concurrency]{concurrently}.
    \item There is no global clock\,--\,no~time synchronization among components.
    \item Components fail independently\,--\,if~one~component fails, other components are~not~affected.
\end{itemize}
\noindent Examples are~computer networks (including the~\hyperref[internetweb]{Internet}) or~telephone networks.

\newsubsection{Distributed Version Control System}
\index{Distributed version control system}
\label{distributedversioncontrolsystem}
It's~a~version control system where each user owns a~copy (mirror) of~the~whole code base including the~whole history. The~typical example of~such system is~\hyperref[git]{Git}.

\newsection{Multitasking}
\index{Multitasking}
\label{multitasking}

\newsection{Concurrency}
\index{Concurrency}
\label{concurrency}

\newsection{Loose Coupling VS Tight Coupling}
\index{Loose coupling}
\index{Tight coupling}
\label{loosetightcoupling}

\newsection{Base64}
\index{Base64}
\label{base64}
It's an~encoding used for~representation of~any array of~bytes as an~ASCII string. The~name refers to the~size of~the~set of~resulting characters, which is~64. It~encodes always three bytes to~four characters. If~the~length of~the~input byte array is~not~divisible by~three, one or~two special bytes are~added to~its~end. This results in~one or~two equals signs at~the~end of~the~resulting string.

\newsection{Shell VS CLI VS GUI}
\index{Shell}
\index{CLI}
\index{GUI}
\label{shellcligui}
\begin{itemize}
    \item \textbf{Shell} is any software for~controlling \hyperref[os]{operating system}.
    \item \textbf{CLI} (Command Line Interface) is~a~user interface for~controlling specific software in~a~form of~single text line to~which commands are~typed. Shells typically (but~not~always) exist in~a~CLI form. Windows command line or~a~\hyperref[unixlinux]{Linux} terminal are~shells. There can also be CLIs that are~not shells, for~example Python console.
    \item \textbf{GUI} (Graphical User Interface) is~a~user interface for~controlling specific software in~a~graphic form. Even shells can, and~often~do, exist in~a~GUI form. For~example, Windows screen (or~GUI screen~of any~other~\hyperref[os]{OS}) is~a~shell.
\end{itemize}

\newsection{Application Programming Interface (API)}
\index{Application programming interface}
\index{API}
\label{api}
It's~a~part of~a~software serving for~communication with other software. The~word \textit{application} is~inaccurate, even \hyperref[applicationprocessprogramservicethread]{services} can~have~API (it's~actually typical part of~a~service). It's~a~very broad term. For~example, when a~browser is~requesting \hyperref[internetweb]{web} pages from a~\hyperref[webserver]{web~server}, it~communicates with the~server~API. When a~process is~supposed to~run under an~\hyperref[os]{OS}, it~communicates with the~API of~that~OS. Methods defined in~a~class form an~API (of~instances) of~that~class. And~so~forth.
