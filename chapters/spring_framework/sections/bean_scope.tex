\newsection{Bean Scope}
\index{Bean scope}
\index{Spring bean scope}
\label{beanscope}
By default Spring beans are~\hyperref[singletondp]{singletons}. That means whenever you call the~bean retrieval (\textit{context.getBean("wantedBeanId", ...)}), you~always get a~reference to~the same object. This~is OK when you~have stateless beans, it's memory--effective. However, when your beans holds some states in~their variables that affect their methods behavior, it~can~get pretty messy. For~this situation it's better to~always create a~new instance of~the~bean class. This~can~be achieved by~specifying the~attribute \textit{scope} with the~value \hyperref[prototypedp]{\textit{prototype}} in~the~\textit{bean} element.

\example
\begin{lstlisting}[language=XML, title={Configuration XML}]
    <?xml version="1.0" encoding="UTF-8"?>
    <beans ...>
      <bean id="(*\tikzmarknodebf{bs1xml1singbeanid}{singletonBeanId}[ForestGreen]*)" class="somepackage.subpackage.SingletonClass">
        ...
      </bean>
      <bean id="(*\tikzmarknodebf{bs1xml1protbeanid}{prototypeBeanId}[ForestGreen]*)" class="somepackage.subpackage.PrototypeClass" scope="prototype">
        ...
      </bean>
    </beans>
\end{lstlisting}
\begin{lstlisting}[language=Java, title={Usage}]
    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("configurationFile.xml");

    SingletonClassInterface singletonInstance1 = context.getBean("(*\tikzmarknodebf{bs1java1singbeanid1}{singletonBeanId}[ForestGreen]*)", SingletonClassInterface.class);
    SingletonClassInterface singletonInstance2 = context.getBean("(*\tikzmarknodebf{bs1java1singbeanid2}{singletonBeanId}[ForestGreen]*)", SingletonClassInterface.class);

    PrototypeClassInterface prototypeInstance1 = context.getBean("(*\tikzmarknodebf{bs1java1protbeanid1}{prototypeBeanId}[ForestGreen]*)", PrototypeClassInterface.class);
    PrototypeClassInterface prototypeInstance2 = context.getBean("(*\tikzmarknodebf{bs1java1protbeanid2}{prototypeBeanId}[ForestGreen]*)", PrototypeClassInterface.class);

    context.close();
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \drawarrow{[xshift=-6mm]bs1xml1singbeanid.south}{[xshift=-9mm] bs1java1singbeanid1}
    \drawarrow{[xshift=-6mm]bs1xml1singbeanid.south}{[xshift=-3mm] bs1java1singbeanid2}
    \drawarrow{[xshift=6mm]bs1xml1protbeanid.south}{[xshift=9mm] bs1java1protbeanid1}[red]
    \drawarrow{[xshift=6mm]bs1xml1protbeanid.south}{[xshift=3mm] bs1java1protbeanid2}[red]
\end{tikzpicture}

\noindent Although a~bean is~requested four times, the~code creates only three bean instances. Two~variables of~the~type \textit{SingletonClassInterface} both refer to~the~same object.

\note You~can even use the~same class for~both singleton and prototype. That's absolutely valid. But~it~can~be tricky, try~to avoid~that.

\note You can even specify the~\hyperref[singletondp]{singleton} behavior by setting the~value \textit{singleton} to~the~attribute \textit{scope}, but~that's an~equivalent of~omitting the~\textit{scope} attribute, therefore, it's~useless.

\newsubsection{Using Java Annotations}
\label{bsannotations}
Specifying a~bean scope with \hyperref[javaannotation]{Java annotations} is really simple. The~bean class is~annotated with the~\textit{Scope} annotation with the~desired scope as~argument.

\example
\begin{lstlisting}[language=Java, title={Bean class with the prototype scope set by the annotation}]@@>@Component<@@("prototypeBeanId")
    @@>@Scope<@@("prototype")
    public class PrototypeClass implements PrototypeClassInterface {
        ...
    }
\end{lstlisting}

\warning If~you configure a~bean in~the~XML configuration file, the~scope will be taken from there even when you enable the~component scanning and~use the~\textit{Scope} annotation for~the~bean class. I.e., if~you don't mention the~scope in~the~XML, the~default one\,--\,singleton\,--\,will be used whatever you~put to~the~\textit{Scope} annotation.

\newsubsection{Configuration with Java Code (No XML)}
The~annotation \textit{Scope} can~be applied even to~a~bean--creating method in~a~configuration class. The~bean class instantiated by~such~method then behaves accordingly to~the~set scope. The~default behavior for~method--instantiated beans (without a~scope~set) is the~usual \hyperref[singletondp]{singleton}.

\warning As~in~previous cases, even the~java--configured scope overrides the~scope configured by~annotations in~bean classes. When you configure a~bean in~the~configuration class using a~bean--creating method, the~scope is~taken from this method. And~when nothing is~configured for~the~method, the~bean will~be always singleton, even when you \hyperref[iocnoxml]{enable component scanning by~Java configuration} and~\hyperref[bsannotations]{set a~different scope by~an~annotation of~the~bean class}.

\example
\enlargethispage{10mm}
\thispagestyle{empty}
\begin{lstlisting}[language=Java, title={Configuration class with a prototype bean--creating metod}]@>@Configuration
    @>@Configuration
    public class ConfigurationClass {
        @>@Bean
        @@>@Scope<@@("prototype")
        public PrototypeClassInterface prototypeBeanMethod() {
            return new PrototypeClass(...);
        }
    }
\end{lstlisting}
\newpage
