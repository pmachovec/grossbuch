\newsection{Procedural Programming}
\index{Procedural programming}
It's~a~variation of~the~\hyperref[imperativeprogramming]{imperative programming}.
A~procedural program is~a~top--down sequence of~statements -- a~procedure -- that, based on~input \hyperref[parameterargument]{arguments}, performs a~certain action.
The~main procedure can~break the~initial problem to~smaller subprocedures and~these can~be broken further until a~subprocedure is~simple enough to~be~solved.

The~\hyperref[imperativeprogramming]{imperative} \hyperref[objectorientedprogramming]{object--oriented} programming partially uses the~procedural approach -- a~sequence of~steps is~executed from~the~start to~the~end.
But~the~difference is in~data handling.
In~real procedural programming tools for~data manipulation are~not~encapsulated together with data.
Data are~passed through the~procedure in~a~form of~a~\hyperref[datastructure]{data structure}, also called \textit{record}, and~adjusted at~various places.

The~procedural paradigm is easier to~grab than~the~object--oriented paradigm, but~its~main disadvantage is a~very tight coupling of~all~parts of~programs.
When some step is changed at~the~beginning of~a~program procedure, it~can~affect data handling and~it~might be necessary to~adjust some following steps.
The~bigger the~program~is, the~worse impact changes have.

Old~programming languages are procedural, for~example Pascal, C or~Fortran.
Even in~modern languages, and~even in~those told to~be object--oriented, it's~possible to~use the~procedural paradigm.
When a~program is~small, for~example, a~\hyperref[scriptinglanguages]{script}, it's~more convenient to~handle it as~a~procedure.
