\newchapter{Java Basics}
\label{java}

\newsection{Bytecode}
\index{Bytecode}
\label{bytecode}
Bytecode is the result of compilation of Java code.
It's stored in \textit{.class} files.
For~people it's an unreadable mess (it's a type of \hyperref[bytecodebinarycode]{binary code}), however it isn't the machine code which a processor can read.
It must be read and further transformed to~the~machine code by JVM, i.e.,~it's a~middle step between written Java code and its execution.
The reason of this approach is that bytecode is transferable between platforms (that's why sometimes it's~called \textit{portable code})\,--\,no~matter on what \hyperref[platform]{platform} (platform\,=\,OS\,+\,hardware in~this~case, hardware\,=\,\hyperref[32bvs64b]{32b~VS~64b}) the original Java code was~written and~compiled, the~resulting bytecode will be executable on~any~other platform.
The~thing which is different for~each platform is~\hyperref[jdkjrejvm]{JRE}.

For~comparison consider C++.
In~this programming language the~result of~compilation is directly the~machine code, which must be different for~each platform, i.e.,~the~thing in C++ which is different for~each platform is the~ompiler.

By~the~way the approach with middle--step code is used also by~C\#, which is compiled to~so~called CIL (\textit{Common Intermediate Language}).
The~main difference of~CIL from bytecode is that CIL is human--readable, although reading it is quite complicated (and~useless).

\newsubsection{Bytecode VS Binary Code}
\index{Binary code}
\label{bytecodebinarycode}
Binary code is generally any code in a~form readable for a~computer.
It can~be machine code read by processors, bytecode read by JVMs, stored database data read by database software etc.
The typical sign of binary code is that it can't~be read by humans.
By this definition the~C\#'s~CIL mentioned earlier is not a~binary code.

When working with Java, you can meet the~term \textit{Java~binaries}.
This refers to \textit{.class} files with bytecode, because the bytecode is~a~form of~binary code.
\newpage

\newsection{JDK VS JRE VS JVM}
\index{JDK}
\index{Java Development Kit}
\index{JRE}
\index{Java Runtime Environment}
\index{JVM}
\index{Java Virtual Machine}
\label{jdkjrejvm}
\begin{itemize}
    \itembf{JDK} stands for~\textit{Java Development Kit}.
            It's a set of tools for development and running Java applications.
    \itembf{JRE} stands for~\textit{Java Runtime Environment}.
            It's~the~most important part of~JDK, which serves for running already compiled code, i.e.,~it's the software transforming \hyperref[bytecode]{bytecode} to machine code.
    \itembf{JVM} stands for~\textit{Java Virtual Machine}.
            It's~the~most important part of JRE, which actually runs the code (transfers \hyperref[bytecode]{bytecode} to machine code), however it can't work alone\,--\,it requires additional tools provided~by~JRE\@.
\end{itemize}

\noindent JDK,~JRE and~JVM are platform--dependent, i.e.,~you~need these things different for~Windows, different for~Linux etc.
The~thing which is~portable is~only the~\hyperref[bytecode]{bytecode}.
When you only want to run Java programs, it's~OK to~install only~JRE, which is~smaller.
However, when you intend to develop Java applications, you of~course need to install~JDK\@.
be aware that when installing JDK (from Oracle), it~also installs a~separate JRE and computers tend to use this JRE by~default.
You should completely ignore this separate JRE\@.
To~do~it you~must set the~environment variable \textit{JAVA\_HOME} to~the~folder of~JDK (not~its~subfolder \textit{bin}, that's added to~the~\textit{Path} variable).

\newsubsection{Typical parts of JDK, that are not included in JRE}
\begin{itemize}
    \item Compiler (the \textit{javac} command)
    \item JavaDoc generator (the \textit{javadoc} command)
    \item Debugger (the \textit{jdb} command)
\end{itemize}

\newsubsection{Typical parts of JRE, that are not included in JVM}
\begin{itemize}
    \item Native \textit{.class} files, i.e.,~binaries of~all~default Java classes (ArrayList, Runtime, Thread,~\dots)
    \item Java execution command (the \textit{java} command)
    \item \hyperref[classloaders]{Classloader}
\end{itemize}

\newsection{Primitive and Reference Data Types}
\index{Data type}
\index{Primitive data type}
\index{Reference data type}
\label{javadatatypes}

\newsection{Access Modifiers}
\index{Access modifier}
\label{javaaccessmodifiers}

\newsubsection{Public}
\index{Public}
\label{javapublic}

\newsubsection{Protected}
\index{Protected}
\label{javaprotected}

\newsubsection{Private}
\index{Private}
\label{javaprivate}

\newsubsection{Static}
\index{Static}
\label{javastatic}
Only \hyperref[variablefieldproperty]{fields} and~methods can~be static.
Such~members, if~not~blocked by~other modifiers, can~be accessed over the~dot notation without a~need of~instantiating the~class containing them.

\example{class with a~static method}
\begin{lstlisting}[language=Java]
    public class ClassWithStaticMethod {
        public static String giveSomeString() {
            ...
        }
    }

    String someString = ClassWithStaticMethod.giveSomeString();
\end{lstlisting}

\warning A~special hidden instance of~the~class is~created for~static members.
This instance is~a~\hyperref[singletondp]{singleton}.
And~this can~be dangerous as~even non--static methods can~access static members.
A~static \hyperref[variablefieldproperty]{field} can~be overridden by~accident and~introduce hardly discoverable bugs.

\example{singleton behavior of~static members}
\begin{lstlisting}[language=Java]
    public class ClassWithStaticMembers {
        private String simpleString;

        public static String getSimpleString() {
            return simpleString;
        }

        public static void setSimpleString(String simpleString) {
            this.simpleString = simpleString;
        }
    }

    ClassWithStaticMembers firstInstance = new ClassWithStaticMembers();
    firsInstance.setSimpleString("FIRST VALUE");
    ...MANY LINES OF CODE...
    ClassWithStaticMembers secondInstance = new ClassWithStaticMembers();
    secondInstance.setSimpleString("SECOND VALUE"); // Writes to the same instance
    ...MANY LINES OF CODE..
    System.out.println(firstInstance.getSimpleString()); // Will print "SECOND VALUE"
\end{lstlisting}

\newsubsection{Final}
\index{Final}
\label{javafinal}

\newsubsection{Synchronized}
\index{Synchronized}
\label{javasynchronized}

\newsubsection{None}
\label{noaccessmodifier}

\newsection{Nested Static Classes}
\index{Nested Static Class}

\newsection{Overriding}
\index{Override}
\label{javaoverride}
It's~a~check mechanism, which tells the~compiler that the~annotated method should override a~method from an~interface or~a~superclass of~the~actual class.
It's~achieved by~\hyperref[javaannotation]{annotating} the~method by~the~\hyperref[javaannotation]{annotation} \textit{@Override}.
When the~compiler encounters a~method with this annotation, it~checks that the~\hyperref[declarationdefinition]{declaration} of~the~method in~the~class matches the~definition in~an~interface or~a~superclass and~if~not, it~stops the~compilation with complaining that \itq{method does not override or implement a method from a supertype}.

\note Today's~IDEs can~detect potential compilation errors on~the~fly including wrong declaration of~a~method with the~\textit{@Override} annotation.
I.e.,~it~will~get the~red zigzag underscore.

\example[this won't be compiled because o~the~bad parameter of~the~child class]
\begin{lstlisting}[language=Java]
    public class Parent {
        public void doSomething() {
            ...SOME IMPLEMENTATION...
        }
    }

    public class Child extends Parent {
        @>@Override
        public void doSomething(Object badParameter) {
            ...SOME IMPLEMENTATION...
        }
    }
\end{lstlisting}

\warning It~serves purely for~overridden method declaration verification.
If~not~used, an~implementation of~a~method in~a~child class will still work.
The~difference is that when used, the~method declaration in~the~child class must~be the~same as~in~the~parent class.

\example[this will be compiled because the~\textit{@Override} annotation is not~used]
\begin{lstlisting}[language=Java]
    public class Parent {
        public void doSomething() {
            ...SOME IMPLEMENTATION...
        }
    }

    public class Child extends Parent {
        public void doSomething(Object notBadParameter) {
            ...SOME IMPLEMENTATION...
        }
    }
\end{lstlisting}

\warning The~enforcement of~method declarations is~not~absolutely strict.
Parameter names can~be different.
Just remember that it's the~only thing that can~be different.
Everyting else\,--\,\hyperref[javaaccessmodifiers]{access modifiers}, names, parameter types and~their order\,--\,must match exactly.
Even descendant classes are~forbidden.

\example[this will be compiled, parameter names can~be different]
\begin{lstlisting}[language=Java]
    public class Parent {
        public void doSomething(Object nameInParent) {
            ...SOME IMPLEMENTATION...
        }
    }

    public class Child extends Parent {
        @>@Override
        public void doSomething(Object nameInChild) {
            ...SOME IMPLEMENTATION...
        }
    }
\end{lstlisting}

\example[this won't be compiled, parameter types must match exactly]
\begin{lstlisting}[language=Java]
    public class Parent {
        public void doSomething(Object sameName) {
            ...SOME IMPLEMENTATION...
        }
    }

    public class Child extends Parent {
        @>@Override
        public void doSomething(String sameName) {
            ...SOME IMPLEMENTATION...
        }
    }
\end{lstlisting}

\warning Static methods can't~be overridden.

\example[this won't be compiled, static methods can't~be overridden]
\begin{lstlisting}[language=Java]
    public class Parent {
        public static void doSomething() {
            ...SOME IMPLEMENTATION...
        }
    }

    public class Child extends Parent {
        @>@Override
        public static void doSomething() {
            ...SOME IMPLEMENTATION...
        }
    }
\end{lstlisting}

\newsubsection{Virtual Methods}
\index{Virtual method}
\label{javavirtualmethods}
In~Java all non--static methods are virtual and~it~can't~be changed.
It~means that when you~have a~variable of~a~class, assign an~instance of~a~subclass to~it and~call a~method that the~subclass overrides, the~implementation from~the~subclass will~be~used.
It~doesn't matter if~the~\textit{@Override} annotation is~used or~not.
Remember, that's only for~overridden method declaration verification.

\example[note that the \textit{@Override} notation isn't used]
\begin{lstlisting}[language=Java]
    public class Parent {
        public void doSomething() {
            System.out.println("Parent implementation");
        }
    }

    public class Child extends Parent {
        public void doSomething() {
            System.out.println("Child implementation");
        }
    }

    Parent virtualParent = new Child();
    virtualParent.doSomething(); @>// Will print "Child implementation"
\end{lstlisting}

\warning As~static methods can't~be overridden, virtualization doesn't work for~them, not~even when a~static method is~called on~a~concrete instance.

\example
\begin{lstlisting}[language=Java]
    public class Parent {
        public static void doSomething() {
            System.out.println("Parent implementation");
        }
    }

    public class Child extends Parent {
        public static void doSomething() {
            System.out.println("Child implementation");
        }
    }

    Parent virtualParent = new Child();
    virtualParent.doSomething(); @>// Will print "Parent implementation"
\end{lstlisting}

\note If~only one~method implementation (either in~a~parent or~in~a~child) is~static, the~compilation fails.
When two methods in~two classes in~a~parent--child relation have the~same name, only parameter names can~be different, everything else, including the~keyword \textit{static}, must match.

\newsection{POJO}
\index{POJO}
\label{pojo}
The~abbreviation stands for~\itq{Plain Old Java Object}.
It~denotes \textbf{an~instance} of~a~Java Class not~bound by any~restriction other than those given~by basic Java specification.
There~are three basic rules for~a~POJO class:
\begin{itemize}
    \item It~can't extend any~prespecified class.
    \item It~can't implement any~prespecified interface.
    \item It~can't contain any~prespecified \hyperref[javaannotation]{annotation}.
\end{itemize}
\noindent The~word \textit{prespecified} denotes any~component (interface, class,~\dots) that is directly defined in~the~code or loaded from a~third--party framework.
For~example, instances of~\hyperref[javabeans]{Java Beans} are~POJOs, although \hyperref[javabeans]{Java Beans} implement the~interface \hyperref[serialization]{\textit{Serializable}}, because the~interface comes from the~default~\hyperref[jdkjrejvm]{JRE}.

\warning Only first two rules are strict.
The~rule forbidding prespecified annotations is~softened when working with some frameworks, typically some persistence.
The~softened version says that if~a~class is a~POJO class before adding framework annotations and~become POJO class after removing framework annotations is still a~POJO class.

\warning You~can also meet claims that all variables must be accessible by getters or there should be no behavior, i.e., that POJOs contain only private variables, getters and setters (not~necessarily for~all variables).
All~claims at~least agree on~that POJOs can have parametrical constructors (opposite to~\hyperref[javabeans]{Java Beans}).

\newsection{Java Beans}
\index{Beans}
\index{Java beans}
\label{javabeans}
Java Bean is every~class that follows these three~restrictions:
\begin{itemize}
    \item It~implements the~interface \textit{Serializable}, i.e.,~its instances are~\hyperref[serialization]{serializable}.
    \item All its \hyperref[variablefieldproperty]{properties} are~private variables accessible by~getters and~setters in~the~form \textit{get\dots} and~\textit{set\dots}
    \item It has a~public zero--parameter constructor.
\end{itemize}
\noindent Following these restrictions enables libraries to~process instances of~beans in~a~predefined way.
For~example, if~a~library wants to~stream an~instance passed into the~library, the~library knows it~can do~it because the~instance is~serializable.

\warning Similarly to~\hyperref[pojo]{POJO} classes there can~be claims that Java Beans don't contain any~behavior, i.e., they contain only properties, zero--parameter constructor, getters and~setters (for~all variables).

\newsection{Enterprise Java Beans (EJB)}
\index{Enterprise Java Beans}
\index{EJB}
\label{ejb}
An~Enterprise Java Bean is a~server--side run component performing a~specific task.
EJBs~form huge \hyperref[distributedsystem]{distributed} server--side systems handling security, transaction processing, persistence etc.
One~EJB can~consist of~more classes and~interfaces (one~EJB\,=\,more files).
The~code uses special \hyperref[annotations]{annotations} provided by~Java~EE libraries.
EJBs must be deployed on a~specialized \hyperref[applicationserver]{application servers} like JBoss or~Glassfish.
EJB~specification was extensively enhanced in~last years, but~it still is quite a~challenging topic.

In~the~past there were no~annotations.
The~specification was~given by~interfaces.
This lead to~a~\hyperref[loosetightcoupling]{tight coupling} between Java~EE libraries and~the~written code, lots of~useless methods enforced by~interfaces, hard implementation, hard maintenance and~overall mess in~the~code.
Furthermore, EJB systems were extremely slow.
That's why the~\hyperref[springframework]{Spring framework} was~introduced by~the~developers community.
Although there was the~mentioned extensive enhancement of~EJB specification, it~still caries the~stigma of~unusable crap and~the~\hyperref[springframework]{Spring framework} remains much more popular.

\warning EJB classes are \textbf{not} \hyperref[javabeans]{Java beans}.
However, with respect to~Java~EE, they're \hyperref[pojo]{POJOs}\,--\,they use only Java~EE default annotations.
In~the~dark past they weren't even that.

\warning The~most popular \hyperref[applicationserver]{application server}\,--\,\hyperref[tomcat]{Tomcat}\,--\,doesn't support EJBs.

\newsection{Checked VS Unchecked Exceptions}
\index{Exception}
\index{Checked exception}
\index{Unchecked exception}

\newsection{Array Length}
\index{Array}
\index{Array length}

\newsection{Classpath}
\index{Classpath}
\label{classpath}

\newsection{Classloaders}
\index{Classloader}
\label{classloaders}

\newsection{Javax}
\index{Javax}
\label{javax}

\newsection{Garbage Collector}
\index{Garbage collector}
\label{garbagecollector}
